<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M√≥dulo 3: Estruturas Condicionais - Curso de Python para Redes Cisco</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <h1>M√≥dulo 3: Estruturas Condicionais</h1>
        <p>Curso de Python para Profissionais de Redes Cisco</p>
    </header>

    <nav>
        <ul>
            <li><a href="index.html">P√°gina Inicial</a></li>
            <li><a href="modulo2.html">‚Üê M√≥dulo Anterior</a></li>
            <li><a href="#operadores">Operadores de Compara√ß√£o</a></li>
            <li><a href="#if-elif-else">Estruturas if, elif e else</a></li>
            <li><a href="#operadores-logicos">Operadores L√≥gicos</a></li>
            <li><a href="#aninhadas">Estruturas Aninhadas</a></li>
            <li><a href="#exercicios">Exerc√≠cios</a></li>
            <li><a href="#avaliacao">Avalia√ß√£o</a></li>
            <li><a href="#referencias">Refer√™ncias</a></li>
            <li><a href="modulo4.html">Pr√≥ximo M√≥dulo ‚Üí</a></li>
        </ul>
    </nav>

    <main>
        <section id="introducao">
            <h2>Introdu√ß√£o √†s Estruturas Condicionais</h2>
            
            <p>As estruturas condicionais s√£o fundamentais na programa√ß√£o, pois permitem que os programas tomem decis√µes com base em condi√ß√µes espec√≠ficas. Em automa√ß√£o de redes, essas estruturas s√£o essenciais para criar scripts inteligentes que podem reagir a diferentes situa√ß√µes, como verificar o status de dispositivos, tomar decis√µes com base em m√©tricas de desempenho ou implementar l√≥gica de troubleshooting.</p>
            
            <p>Neste m√≥dulo, exploraremos como implementar l√≥gica de decis√£o em Python, permitindo que seus scripts avaliem condi√ß√µes e executem diferentes blocos de c√≥digo dependendo do resultado dessas avalia√ß√µes. Aprenderemos sobre operadores de compara√ß√£o, estruturas if-elif-else, operadores l√≥gicos e estruturas condicionais aninhadas, sempre com exemplos pr√°ticos voltados para o ambiente de redes Cisco.</p>
            
            <div class="note">
                <h4>Import√¢ncia para Profissionais de Redes:</h4>
                <p>As estruturas condicionais s√£o particularmente importantes para profissionais de redes porque permitem automatizar processos de tomada de decis√£o que normalmente exigiriam interven√ß√£o manual. Por exemplo, voc√™ pode criar scripts que verificam automaticamente a disponibilidade de dispositivos, analisam logs em busca de padr√µes espec√≠ficos, ou implementam pol√≠ticas de configura√ß√£o com base em diferentes crit√©rios.</p>
            </div>
        </section>

        <section id="operadores">
            <h2>Operadores de Compara√ß√£o</h2>
            
            <p>Os operadores de compara√ß√£o s√£o usados para comparar valores e retornam um resultado booleano (True ou False). Esses operadores s√£o a base para criar express√µes condicionais em Python.</p>
            
            <h3>Principais Operadores de Compara√ß√£o</h3>
            
            <table>
                <tr>
                    <th>Operador</th>
                    <th>Nome</th>
                    <th>Exemplo</th>
                    <th>Resultado</th>
                </tr>
                <tr>
                    <td>==</td>
                    <td>Igual a</td>
                    <td>5 == 5</td>
                    <td>True</td>
                </tr>
                <tr>
                    <td>!=</td>
                    <td>Diferente de</td>
                    <td>5 != 3</td>
                    <td>True</td>
                </tr>
                <tr>
                    <td>></td>
                    <td>Maior que</td>
                    <td>5 > 3</td>
                    <td>True</td>
                </tr>
                <tr>
                    <td><</td>
                    <td>Menor que</td>
                    <td>5 < 3</td>
                    <td>False</td>
                </tr>
                <tr>
                    <td>>=</td>
                    <td>Maior ou igual a</td>
                    <td>5 >= 5</td>
                    <td>True</td>
                </tr>
                <tr>
                    <td><=</td>
                    <td>Menor ou igual a</td>
                    <td>5 <= 3</td>
                    <td>False</td>
                </tr>
            </table>
            
            <h3>Exemplos em Contexto de Redes</h3>
            
            <p>Vamos ver como esses operadores podem ser aplicados em cen√°rios de redes:</p>
            
            <pre><code># Verificando se um dispositivo est√° ativo com base no c√≥digo de status
status_code = 1  # 1 = ativo, 0 = inativo
is_active = status_code == 1
print(f"O dispositivo est√° ativo? {is_active}")  # True

# Verificando se a utiliza√ß√£o de CPU est√° acima do limite
cpu_utilization = 85.5
threshold = 80
is_high_cpu = cpu_utilization > threshold
print(f"CPU est√° acima do limite? {is_high_cpu}")  # True

# Verificando se a vers√£o do IOS √© compat√≠vel
current_ios = "15.2"
minimum_required = "15.0"
is_compatible = current_ios >= minimum_required
print(f"A vers√£o do IOS √© compat√≠vel? {is_compatible}")  # True

# Verificando se um endere√ßo IP pertence a uma sub-rede espec√≠fica
# (simplificado para fins did√°ticos)
ip_first_octet = 192
subnet_first_octet = 192
is_same_subnet = ip_first_octet == subnet_first_octet
print(f"O IP est√° na mesma sub-rede? {is_same_subnet}")  # True</code></pre>
            
            <h3>Compara√ß√£o de Strings</h3>
            
            <p>Em Python, tamb√©m podemos comparar strings usando os mesmos operadores. A compara√ß√£o √© feita lexicograficamente (ordem alfab√©tica):</p>
            
            <pre><code># Comparando nomes de dispositivos
device1 = "Router-Core-01"
device2 = "Router-Edge-01"

print(device1 == device2)  # False
print(device1 != device2)  # True
print(device1 < device2)   # False (R vem antes de S na ordem alfab√©tica)
print(device1 > device2)   # True

# Verificando se um comando cont√©m uma palavra espec√≠fica
command = "show ip interface brief"
print("ip" in command)     # True
print("vlan" in command)   # False

# Verificando prefixos de interfaces
interface = "GigabitEthernet0/1"
print(interface.startswith("Gigabit"))  # True
print(interface.endswith("0/1"))        # True</code></pre>
            
            <div class="note">
                <h4>Dica para Profissionais de Redes:</h4>
                <p>Ao comparar vers√µes de software (como vers√µes do IOS), lembre-se que a compara√ß√£o de strings pode n√£o funcionar como esperado. Por exemplo, "15.10" seria considerado menor que "15.2" em uma compara√ß√£o de strings, embora numericamente 15.10 seja maior que 15.2. Para esses casos, considere converter as partes num√©ricas para inteiros antes de comparar.</p>
            </div>
        </section>

        <section id="if-elif-else">
            <h2>Estruturas if, elif e else</h2>
            
            <p>As estruturas condicionais em Python permitem executar diferentes blocos de c√≥digo com base em condi√ß√µes espec√≠ficas. A sintaxe b√°sica inclui as palavras-chave <code>if</code>, <code>elif</code> (abrevia√ß√£o de "else if") e <code>else</code>.</p>
            
            <h3>Estrutura if Simples</h3>
            
            <p>A estrutura <code>if</code> mais b√°sica executa um bloco de c√≥digo apenas se uma condi√ß√£o for verdadeira:</p>
            
            <pre><code># Estrutura if simples
interface_status = "up"

if interface_status == "up":
    print("A interface est√° ativa")
    print("Nenhuma a√ß√£o necess√°ria")

# Sa√≠da: A interface est√° ativa
#        Nenhuma a√ß√£o necess√°ria</code></pre>
            
            <p>Observe que o bloco de c√≥digo dentro do <code>if</code> √© indentado. Em Python, a indenta√ß√£o √© obrigat√≥ria e define o escopo do bloco. A conven√ß√£o √© usar 4 espa√ßos para cada n√≠vel de indenta√ß√£o.</p>
            
            <h3>Estrutura if-else</h3>
            
            <p>A estrutura <code>if-else</code> permite executar um bloco de c√≥digo se a condi√ß√£o for verdadeira e outro bloco se for falsa:</p>
            
            <pre><code># Estrutura if-else
ping_response = False

if ping_response:
    print("O dispositivo est√° respondendo ao ping")
    print("Continuando com a configura√ß√£o")
else:
    print("O dispositivo n√£o est√° respondendo ao ping")
    print("Verificando conectividade f√≠sica")

# Sa√≠da: O dispositivo n√£o est√° respondendo ao ping
#        Verificando conectividade f√≠sica</code></pre>
            
            <h3>Estrutura if-elif-else</h3>
            
            <p>A estrutura <code>if-elif-else</code> permite verificar m√∫ltiplas condi√ß√µes em sequ√™ncia:</p>
            
            <pre><code># Estrutura if-elif-else
cpu_utilization = 78

if cpu_utilization >= 90:
    print("ALERTA CR√çTICO: Utiliza√ß√£o de CPU extremamente alta!")
    print("Iniciando procedimentos de mitiga√ß√£o")
elif cpu_utilization >= 80:
    print("ALERTA: Utiliza√ß√£o de CPU alta")
    print("Monitorando de perto")
elif cpu_utilization >= 70:
    print("AVISO: Utiliza√ß√£o de CPU moderada")
    print("Verificando tend√™ncias")
else:
    print("Utiliza√ß√£o de CPU normal")
    print("Nenhuma a√ß√£o necess√°ria")

# Sa√≠da: AVISO: Utiliza√ß√£o de CPU moderada
#        Verificando tend√™ncias</code></pre>
            
            <p>Neste exemplo, as condi√ß√µes s√£o verificadas em ordem. Assim que uma condi√ß√£o verdadeira √© encontrada, o bloco correspondente √© executado e as condi√ß√µes restantes s√£o ignoradas. Se nenhuma condi√ß√£o for verdadeira, o bloco <code>else</code> √© executado.</p>
            
            <h3>Aplica√ß√£o em Redes: Verifica√ß√£o de Alcan√ßabilidade</h3>
            
            <p>Vamos ver um exemplo mais completo de como usar estruturas condicionais para verificar a alcan√ßabilidade de dispositivos de rede:</p>
            
            <pre><code>import subprocess
import platform

def check_device_reachability(ip_address):
    """
    Verifica se um dispositivo est√° acess√≠vel via ping
    Retorna um c√≥digo de status e uma mensagem
    """
    # Determina o par√¢metro correto para contagem de ping baseado no sistema operacional
    param = "-n" if platform.system().lower() == "windows" else "-c"
    
    # Executa o comando ping
    command = ["ping", param, "2", ip_address]
    
    try:
        # Executa o ping e captura o resultado
        result = subprocess.call(command, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        
        # Analisa o resultado
        if result == 0:
            return 0, "Dispositivo acess√≠vel"
        else:
            return 1, "Dispositivo inacess√≠vel via ping"
    except Exception as e:
        return 2, f"Erro ao executar o ping: {e}"

# Lista de dispositivos para verificar
devices = [
    {"name": "Router-Core", "ip": "192.168.1.1", "role": "core"},
    {"name": "Switch-Access-1", "ip": "192.168.1.2", "role": "access"},
    {"name": "Router-Edge", "ip": "192.168.1.254", "role": "edge"}
]

# Verificando cada dispositivo
for device in devices:
    print(f"\nVerificando dispositivo: {device['name']} ({device['ip']})")
    status_code, message = check_device_reachability(device['ip'])
    
    if status_code == 0:
        print(f"‚úÖ {message}")
        
        # A√ß√µes espec√≠ficas baseadas no papel do dispositivo
        if device['role'] == "core":
            print("  ‚Üí Verificando tabela de roteamento do Core Router")
        elif device['role'] == "access":
            print("  ‚Üí Verificando status das portas do Access Switch")
        elif device['role'] == "edge":
            print("  ‚Üí Verificando conectividade WAN do Edge Router")
    
    elif status_code == 1:
        print(f"‚ùå {message}")
        print("  ‚Üí Iniciando procedimento de troubleshooting:")
        print("     1. Verificando conectividade f√≠sica")
        print("     2. Verificando configura√ß√£o de IP")
        print("     3. Verificando firewall e ACLs")
    
    else:
        print(f"‚ö†Ô∏è {message}")
        print("  ‚Üí Verificando configura√ß√£o do sistema local")</code></pre>
            
            <p>Este exemplo demonstra como usar estruturas condicionais para implementar uma l√≥gica de verifica√ß√£o de dispositivos de rede, com a√ß√µes espec√≠ficas baseadas no papel de cada dispositivo e no resultado da verifica√ß√£o de alcan√ßabilidade.</p>
            
            <div class="note">
                <h4>Dica para Profissionais de Redes:</h4>
                <p>Ao criar scripts de automa√ß√£o com estruturas condicionais, considere todos os poss√≠veis estados e resultados. Em ambientes de rede, √© importante tratar n√£o apenas os casos de sucesso e falha, mas tamb√©m situa√ß√µes intermedi√°rias ou inesperadas, como timeouts, respostas parciais ou erros de autentica√ß√£o.</p>
            </div>
        </section>

        <section id="operadores-logicos">
            <h2>Operadores L√≥gicos</h2>
            
            <p>Os operadores l√≥gicos permitem combinar m√∫ltiplas condi√ß√µes em uma √∫nica express√£o. Em Python, os principais operadores l√≥gicos s√£o <code>and</code>, <code>or</code> e <code>not</code>.</p>
            
            <h3>Operador and</h3>
            
            <p>O operador <code>and</code> retorna <code>True</code> apenas se ambas as condi√ß√µes forem verdadeiras:</p>
            
            <table>
                <tr>
                    <th>Express√£o</th>
                    <th>Resultado</th>
                </tr>
                <tr>
                    <td>True and True</td>
                    <td>True</td>
                </tr>
                <tr>
                    <td>True and False</td>
                    <td>False</td>
                </tr>
                <tr>
                    <td>False and True</td>
                    <td>False</td>
                </tr>
                <tr>
                    <td>False and False</td>
                    <td>False</td>
                </tr>
            </table>
            
            <pre><code># Exemplo com operador and
cpu_high = True
memory_low = False

if cpu_high and memory_low:
    print("Situa√ß√£o cr√≠tica: CPU alta e mem√≥ria baixa")
else:
    print("Situa√ß√£o n√£o cr√≠tica")

# Sa√≠da: Situa√ß√£o n√£o cr√≠tica</code></pre>
            
            <h3>Operador or</h3>
            
            <p>O operador <code>or</code> retorna <code>True</code> se pelo menos uma das condi√ß√µes for verdadeira:</p>
            
            <table>
                <tr>
                    <th>Express√£o</th>
                    <th>Resultado</th>
                </tr>
                <tr>
                    <td>True or True</td>
                    <td>True</td>
                </tr>
                <tr>
                    <td>True or False</td>
                    <td>True</td>
                </tr>
                <tr>
                    <td>False or True</td>
                    <td>True</td>
                </tr>
                <tr>
                    <td>False or False</td>
                    <td>False</td>
                </tr>
            </table>
            
            <pre><code># Exemplo com operador or
link_primary_down = True
link_backup_down = False

if link_primary_down or link_backup_down:
    print("Alerta: Pelo menos um link est√° inativo")
else:
    print("Todos os links est√£o ativos")

# Sa√≠da: Alerta: Pelo menos um link est√° inativo</code></pre>
            
            <h3>Operador not</h3>
            
            <p>O operador <code>not</code> inverte o valor de uma express√£o booleana:</p>
            
            <table>
                <tr>
                    <th>Express√£o</th>
                    <th>Resultado</th>
                </tr>
                <tr>
                    <td>not True</td>
                    <td>False</td>
                </tr>
                <tr>
                    <td>not False</td>
                    <td>True</td>
                </tr>
            </table>
            
            <pre><code># Exemplo com operador not
interface_up = False

if not interface_up:
    print("A interface est√° inativa")
else:
    print("A interface est√° ativa")

# Sa√≠da: A interface est√° inativa</code></pre>
            
            <h3>Combinando Operadores L√≥gicos</h3>
            
            <p>Os operadores l√≥gicos podem ser combinados para criar express√µes mais complexas:</p>
            
            <pre><code># Combinando operadores l√≥gicos
cpu_utilization = 85
memory_utilization = 60
disk_utilization = 90

# Verificando se pelo menos dois recursos est√£o com alta utiliza√ß√£o
high_cpu = cpu_utilization > 80
high_memory = memory_utilization > 80
high_disk = disk_utilization > 80

if (high_cpu and high_memory) or (high_cpu and high_disk) or (high_memory and high_disk):
    print("ALERTA: Pelo menos dois recursos com alta utiliza√ß√£o")
else:
    print("Situa√ß√£o normal ou apenas um recurso com alta utiliza√ß√£o")

# Sa√≠da: ALERTA: Pelo menos dois recursos com alta utiliza√ß√£o</code></pre>
            
            <h3>Aplica√ß√£o em Redes: Tomada de Decis√£o Baseada em M√∫ltiplos Fatores</h3>
            
            <p>Vamos ver um exemplo mais completo de como usar operadores l√≥gicos para tomar decis√µes em um ambiente de rede:</p>
            
            <pre><code># Fun√ß√£o para verificar se um dispositivo precisa de manuten√ß√£o
def check_device_maintenance_needed(device_info):
    """
    Verifica se um dispositivo precisa de manuten√ß√£o com base em m√∫ltiplos fatores
    """
    # Extraindo informa√ß√µes do dispositivo
    uptime_days = device_info.get('uptime_days', 0)
    cpu_avg = device_info.get('cpu_avg', 0)
    memory_free_percent = device_info.get('memory_free_percent', 100)
    interface_errors = device_info.get('interface_errors', 0)
    ios_version = device_info.get('ios_version', '')
    ios_vulnerabilities = device_info.get('ios_vulnerabilities', 0)
    
    # Definindo limiares
    HIGH_UPTIME = 180  # 6 meses
    HIGH_CPU = 75
    LOW_MEMORY = 20
    HIGH_ERRORS = 100
    CRITICAL_VULNERABILITIES = 2
    
    # Verificando condi√ß√µes cr√≠ticas (qualquer uma dessas condi√ß√µes justifica manuten√ß√£o imediata)
    critical_condition = (
        (ios_vulnerabilities >= CRITICAL_VULNERABILITIES) or
        (memory_free_percent <= LOW_MEMORY and cpu_avg >= HIGH_CPU)
    )
    
    # Verificando condi√ß√µes de alerta (pelo menos duas dessas condi√ß√µes justificam manuten√ß√£o planejada)
    warning_conditions = [
        uptime_days >= HIGH_UPTIME,
        cpu_avg >= HIGH_CPU,
        memory_free_percent <= LOW_MEMORY,
        interface_errors >= HIGH_ERRORS
    ]
    
    warning_count = sum(1 for condition in warning_conditions if condition)
    warning_condition = warning_count >= 2
    
    # Determinando o resultado
    if critical_condition:
        return "CR√çTICO", "Manuten√ß√£o imediata necess√°ria"
    elif warning_condition:
        return "ALERTA", "Manuten√ß√£o planejada recomendada"
    else:
        return "OK", "Nenhuma manuten√ß√£o necess√°ria no momento"

# Exemplos de dispositivos
devices = [
    {
        'name': 'Router-Core-01',
        'uptime_days': 210,
        'cpu_avg': 65,
        'memory_free_percent': 35,
        'interface_errors': 50,
        'ios_version': '15.2(4)M1',
        'ios_vulnerabilities': 1
    },
    {
        'name': 'Switch-Access-02',
        'uptime_days': 45,
        'cpu_avg': 85,
        'memory_free_percent': 15,
        'interface_errors': 120,
        'ios_version': '16.3.5',
        'ios_vulnerabilities': 0
    },
    {
        'name': 'Router-Edge-01',
        'uptime_days': 30,
        'cpu_avg': 45,
        'memory_free_percent': 60,
        'interface_errors': 10,
        'ios_version': '15.1(4)M',
        'ios_vulnerabilities': 3
    }
]

# Verificando cada dispositivo
print("Relat√≥rio de Manuten√ß√£o de Dispositivos")
print("======================================")

for device in devices:
    status, message = check_device_maintenance_needed(device)
    
    # Formatando a sa√≠da com base no status
    if status == "CR√çTICO":
        status_icon = "üî¥"
    elif status == "ALERTA":
        status_icon = "üü†"
    else:
        status_icon = "üü¢"
    
    print(f"\n{status_icon} {device['name']}: {status}")
    print(f"   {message}")
    
    # Exibindo detalhes que contribu√≠ram para a decis√£o
    print("   Detalhes:")
    print(f"   - Uptime: {device['uptime_days']} dias")
    print(f"   - CPU m√©dia: {device['cpu_avg']}%")
    print(f"   - Mem√≥ria livre: {device['memory_free_percent']}%")
    print(f"   - Erros de interface: {device['interface_errors']}")
    print(f"   - Vers√£o do IOS: {device['ios_version']}")
    print(f"   - Vulnerabilidades conhecidas: {device['ios_vulnerabilities']}")</code></pre>
            
            <p>Este exemplo demonstra como usar operadores l√≥gicos para implementar uma l√≥gica de decis√£o complexa, avaliando m√∫ltiplos fatores para determinar se um dispositivo de rede precisa de manuten√ß√£o.</p>
            
            <div class="note">
                <h4>Dica para Profissionais de Redes:</h4>
                <p>Ao criar scripts de automa√ß√£o com operadores l√≥gicos, organize suas condi√ß√µes de forma clara e considere usar vari√°veis intermedi√°rias para armazenar resultados parciais. Isso torna o c√≥digo mais leg√≠vel e facilita a manuten√ß√£o, especialmente quando a l√≥gica de decis√£o √© complexa.</p>
            </div>
        </section>

        <section id="aninhadas">
            <h2>Estruturas Condicionais Aninhadas</h2>
            
            <p>As estruturas condicionais aninhadas ocorrem quando uma estrutura condicional est√° dentro de outra. Isso permite criar l√≥gicas de decis√£o mais complexas e hier√°rquicas.</p>
            
            <h3>Sintaxe B√°sica</h3>
            
            <pre><code># Estrutura condicional aninhada
interface_status = "up"
interface_errors = 25

if interface_status == "up":
    print("Interface est√° ativa")
    
    if interface_errors > 0:
        print("Mas h√° erros registrados")
        
        if interface_errors > 100:
            print("N√∫mero de erros √© cr√≠tico")
        else:
            print("N√∫mero de erros est√° dentro do aceit√°vel")
    else:
        print("Sem erros registrados")
else:
    print("Interface est√° inativa")</code></pre>
            
            <p>Neste exemplo, temos tr√™s n√≠veis de estruturas condicionais. Observe como a indenta√ß√£o aumenta para cada n√≠vel aninhado, tornando clara a hierarquia das condi√ß√µes.</p>
            
            <h3>Refatorando Estruturas Aninhadas</h3>
            
            <p>Embora as estruturas aninhadas sejam √∫teis, elas podem tornar o c√≥digo dif√≠cil de ler quando h√° muitos n√≠veis. Uma alternativa √© usar operadores l√≥gicos para combinar condi√ß√µes:</p>
            
            <pre><code># Vers√£o original com estruturas aninhadas
if device_reachable:
    if device_type == "router":
        if ios_version >= "15.0":
            print("Dispositivo compat√≠vel")
        else:
            print("Vers√£o do IOS incompat√≠vel")
    else:
        print("Tipo de dispositivo n√£o suportado")
else:
    print("Dispositivo inacess√≠vel")

# Vers√£o refatorada com condi√ß√µes combinadas
if not device_reachable:
    print("Dispositivo inacess√≠vel")
elif device_type != "router":
    print("Tipo de dispositivo n√£o suportado")
elif ios_version < "15.0":
    print("Vers√£o do IOS incompat√≠vel")
else:
    print("Dispositivo compat√≠vel")</code></pre>
            
            <p>A vers√£o refatorada √© mais plana e geralmente mais f√°cil de entender, especialmente para l√≥gicas complexas.</p>
            
            <h3>Aplica√ß√£o em Redes: Troubleshooting de Conectividade</h3>
            
            <p>Vamos ver um exemplo de como usar estruturas condicionais aninhadas para implementar um fluxo de troubleshooting de conectividade:</p>
            
            <pre><code>def troubleshoot_connectivity(device_ip, device_type):
    """
    Implementa um fluxo de troubleshooting para problemas de conectividade
    """
    print(f"Iniciando troubleshooting para {device_ip} ({device_type})")
    
    # Verificar ping
    ping_successful = check_ping(device_ip)
    
    if ping_successful:
        print("‚úÖ Dispositivo responde ao ping")
        
        # Verificar acesso SSH
        ssh_successful = check_ssh_access(device_ip)
        
        if ssh_successful:
            print("‚úÖ Acesso SSH bem-sucedido")
            
            # Verificar status da interface
            interface_status = get_interface_status(device_ip)
            
            if interface_status == "up":
                print("‚úÖ Interface est√° ativa")
                print("Conectividade verificada com sucesso")
            else:
                print("‚ùå Interface est√° inativa")
                print("Recomenda√ß√£o: Verificar configura√ß√£o da interface")
        else:
            print("‚ùå Falha no acesso SSH")
            
            # Verificar se a porta SSH est√° aberta
            ssh_port_open = check_port_open(device_ip, 22)
            
            if ssh_port_open:
                print("‚úÖ Porta SSH (22) est√° aberta")
                print("Recomenda√ß√£o: Verificar credenciais SSH")
            else:
                print("‚ùå Porta SSH (22) est√° fechada")
                print("Recomenda√ß√£o: Verificar se o servi√ßo SSH est√° ativo no dispositivo")
    else:
        print("‚ùå Dispositivo n√£o responde ao ping")
        
        # Verificar se o dispositivo est√° na mesma sub-rede
        same_subnet = check_same_subnet(device_ip)
        
        if same_subnet:
            print("‚úÖ Dispositivo est√° na mesma sub-rede")
            
            # Verificar ARP
            arp_entry = check_arp_entry(device_ip)
            
            if arp_entry:
                print(f"‚úÖ Entrada ARP encontrada: {arp_entry}")
                print("Recomenda√ß√£o: Verificar firewall ou ACLs")
            else:
                print("‚ùå Nenhuma entrada ARP encontrada")
                print("Recomenda√ß√£o: Verificar se o dispositivo est√° ligado e conectado √† rede")
        else:
            print("‚ùå Dispositivo est√° em outra sub-rede")
            
            # Verificar roteamento
            route_exists = check_route_exists(device_ip)
            
            if route_exists:
                print("‚úÖ Rota para o dispositivo existe")
                print("Recomenda√ß√£o: Verificar firewall, ACLs ou roteamento no caminho")
            else:
                print("‚ùå Nenhuma rota para o dispositivo")
                print("Recomenda√ß√£o: Adicionar rota ou verificar gateway padr√£o")

# Fun√ß√µes auxiliares (simuladas para este exemplo)
def check_ping(ip):
    # Simula√ß√£o: IPs que come√ßam com 10. respondem ao ping
    return ip.startswith("10.")

def check_ssh_access(ip):
    # Simula√ß√£o: apenas alguns IPs espec√≠ficos t√™m SSH acess√≠vel
    return ip in ["10.0.0.1", "10.0.0.2"]

def get_interface_status(ip):
    # Simula√ß√£o: status da interface
    return "up" if ip == "10.0.0.1" else "down"

def check_port_open(ip, port):
    # Simula√ß√£o: verifica√ß√£o de porta
    return ip.startswith("10.")

def check_same_subnet(ip):
    # Simula√ß√£o: verifica√ß√£o de sub-rede
    return ip.startswith("10.") or ip.startswith("192.168.")

def check_arp_entry(ip):
    # Simula√ß√£o: entrada ARP
    if ip == "192.168.1.1":
        return "00:1A:2B:3C:4D:5E"
    return None

def check_route_exists(ip):
    # Simula√ß√£o: verifica√ß√£o de rota
    return not ip.startswith("172.")

# Testando o troubleshooting com diferentes dispositivos
test_devices = [
    {"ip": "10.0.0.1", "type": "router"},  # Tudo OK
    {"ip": "10.0.0.3", "type": "switch"},  # Ping OK, SSH falha, porta aberta
    {"ip": "192.168.1.1", "type": "router"},  # Ping falha, mesma sub-rede, ARP OK
    {"ip": "172.16.0.1", "type": "router"}   # Ping falha, outra sub-rede, sem rota
]

for device in test_devices:
    print("\n" + "=" * 50)
    troubleshoot_connectivity(device["ip"], device["type"])
    print("=" * 50)</code></pre>
            
            <p>Este exemplo demonstra como usar estruturas condicionais aninhadas para implementar um fluxo de troubleshooting de conectividade, com diferentes caminhos de verifica√ß√£o dependendo dos resultados de cada etapa.</p>
            
            <div class="note">
                <h4>Dica para Profissionais de Redes:</h4>
                <p>Ao implementar fluxos de troubleshooting com estruturas condicionais aninhadas, considere desenhar um fluxograma antes de come√ßar a codificar. Isso ajuda a visualizar a l√≥gica e garantir que todos os caminhos poss√≠veis sejam considerados. Al√©m disso, considere dividir l√≥gicas muito complexas em fun√ß√µes separadas para melhorar a legibilidade e manuten√ß√£o do c√≥digo.</p>
            </div>
        </section>

        <section id="exercicios">
            <h2>Exerc√≠cios Pr√°ticos</h2>
            
            <div class="exercise">
                <h4>Exerc√≠cio 1: Classificador de Dispositivos</h4>
                <p>Crie um script Python que classifique dispositivos de rede com base em suas caracter√≠sticas. O script deve:</p>
                <ol>
                    <li>Solicitar ao usu√°rio informa√ß√µes sobre um dispositivo (tipo, n√∫mero de interfaces, suporte a PoE, velocidade m√°xima)</li>
                    <li>Classificar o dispositivo em uma das seguintes categorias: "Core", "Distribution", "Access" ou "Endpoint"</li>
                    <li>Exibir a classifica√ß√£o e uma breve descri√ß√£o do papel t√≠pico desse tipo de dispositivo na rede</li>
                </ol>
                <p>Use estruturas condicionais e operadores l√≥gicos para implementar a l√≥gica de classifica√ß√£o.</p>
            </div>
            
            <div class="solution">
                <h4>Solu√ß√£o do Exerc√≠cio 1:</h4>
                <pre><code>#!/usr/bin/env python3
# Classificador de Dispositivos de Rede

def classify_device(device_type, num_interfaces, poe_support, max_speed):
    """
    Classifica um dispositivo de rede com base em suas caracter√≠sticas
    """
    # Convertendo entradas para tipos apropriados
    num_interfaces = int(num_interfaces)
    poe_support = poe_support.lower() in ['sim', 's', 'yes', 'y', 'true', 't']
    max_speed = float(max_speed)  # em Gbps
    
    # L√≥gica de classifica√ß√£o
    if device_type.lower() in ['router', 'roteador']:
        if num_interfaces >= 24 and max_speed >= 10:
            return "Core", "Roteador central que conecta diferentes partes da rede e geralmente lida com roteamento entre VLANs e conex√µes WAN."
        elif num_interfaces >= 8 and max_speed >= 1:
            return "Distribution", "Roteador intermedi√°rio que agrega conex√µes de dispositivos de acesso e aplica pol√≠ticas."
        else:
            return "Access", "Roteador de borda que fornece conectividade direta para dispositivos finais ou conex√µes WAN menores."
    
    elif device_type.lower() in ['switch', 'comutador']:
        if num_interfaces >= 48 and max_speed >= 40:
            return "Core", "Switch central de alta capacidade que forma a espinha dorsal da rede."
        elif num_interfaces >= 24 and max_speed >= 10:
            return "Distribution", "Switch intermedi√°rio que agrega tr√°fego de switches de acesso e aplica pol√≠ticas."
        elif poe_support and num_interfaces <= 48:
            return "Access", "Switch de acesso que conecta dispositivos finais como computadores, telefones IP e APs."
        else:
            return "Access", "Switch de acesso b√°sico para conectar dispositivos finais."
    
    elif device_type.lower() in ['ap', 'access point', 'ponto de acesso']:
        return "Access", "Dispositivo que fornece conectividade sem fio para dispositivos finais."
    
    elif device_type.lower() in ['firewall', 'ngfw']:
        if num_interfaces >= 8 and max_speed >= 10:
            return "Core", "Firewall de alta capacidade para prote√ß√£o de per√≠metro ou segmenta√ß√£o interna cr√≠tica."
        else:
            return "Distribution", "Firewall para prote√ß√£o de segmentos espec√≠ficos da rede ou conex√µes WAN."
    
    else:
        return "Endpoint", "Dispositivo final que consome servi√ßos de rede, como computadores, impressoras ou telefones IP."

# Interface do usu√°rio
print("Classificador de Dispositivos de Rede")
print("====================================")

try:
    # Coletando informa√ß√µes do dispositivo
    device_type = input("Tipo de dispositivo (router, switch, AP, firewall): ")
    num_interfaces = input("N√∫mero de interfaces: ")
    poe_support = input("Suporte a PoE (sim/n√£o): ")
    max_speed = input("Velocidade m√°xima (em Gbps): ")
    
    # Classificando o dispositivo
    category, description = classify_device(device_type, num_interfaces, poe_support, max_speed)
    
    # Exibindo o resultado
    print("\nResultado da Classifica√ß√£o:")
    print(f"Categoria: {category}")
    print(f"Descri√ß√£o: {description}")
    
    # Recomenda√ß√µes baseadas na categoria
    print("\nRecomenda√ß√µes de Configura√ß√£o:")
    
    if category == "Core":
        print("- Implementar protocolos de roteamento como OSPF ou BGP")
        print("- Configurar redund√¢ncia com HSRP/VRRP")
        print("- Monitorar desempenho e utiliza√ß√£o constantemente")
        print("- Implementar QoS para priorizar tr√°fego cr√≠tico")
    
    elif category == "Distribution":
        print("- Implementar VLANs e roteamento entre VLANs")
        print("- Configurar ACLs para controle de tr√°fego")
        print("- Implementar pol√≠ticas de QoS")
        print("- Considerar redund√¢ncia para links cr√≠ticos")
    
    elif category == "Access":
        print("- Configurar seguran√ßa de porta (port-security)")
        print("- Implementar VLANs para segmenta√ß√£o de tr√°fego")
        print("- Configurar PoE para dispositivos compat√≠veis")
        print("- Implementar prote√ß√µes como DHCP snooping e ARP inspection")
    
    elif category == "Endpoint":
        print("- Garantir atualiza√ß√µes regulares de firmware/software")
        print("- Implementar autentica√ß√£o segura na rede")
        print("- Considerar segmenta√ß√£o em VLAN apropriada")

except ValueError as e:
    print(f"Erro: {e}")
    print("Por favor, certifique-se de inserir valores num√©ricos para o n√∫mero de interfaces e velocidade.")</code></pre>
            </div>
            
            <div class="exercise">
                <h4>Exerc√≠cio 2: Analisador de Logs de Firewall</h4>
                <p>Crie um script Python que analise entradas de log de um firewall e classifique-as com base na severidade e tipo de evento. O script deve:</p>
                <ol>
                    <li>Ler uma lista de entradas de log (fornecidas no c√≥digo)</li>
                    <li>Para cada entrada, extrair informa√ß√µes como timestamp, IP de origem, IP de destino, porta e a√ß√£o (permitir/bloquear)</li>
                    <li>Classificar cada entrada como "Cr√≠tica", "Alerta", "Aviso" ou "Informativa" com base em regras predefinidas</li>
                    <li>Gerar um relat√≥rio resumido com contagens por categoria e listar os eventos cr√≠ticos</li>
                </ol>
            </div>
            
            <div class="solution">
                <h4>Solu√ß√£o do Exerc√≠cio 2:</h4>
                <pre><code>#!/usr/bin/env python3
# Analisador de Logs de Firewall

def parse_log_entry(log_entry):
    """
    Analisa uma entrada de log e extrai informa√ß√µes relevantes
    """
    parts = log_entry.split()
    
    # Estrutura b√°sica esperada: timestamp action src_ip:src_port -> dst_ip:dst_port protocol
    timestamp = parts[0] + " " + parts[1]
    action = parts[2]
    
    # Extraindo IPs e portas
    src_full = parts[3]
    dst_full = parts[5]
    
    src_parts = src_full.split(":")
    dst_parts = dst_full.split(":")
    
    src_ip = src_parts[0]
    src_port = src_parts[1] if len(src_parts) > 1 else "N/A"
    
    dst_ip = dst_parts[0]
    dst_port = dst_parts[1] if len(dst_parts) > 1 else "N/A"
    
    # Extraindo protocolo
    protocol = parts[6] if len(parts) > 6 else "N/A"
    
    return {
        "timestamp": timestamp,
        "action": action,
        "src_ip": src_ip,
        "src_port": src_port,
        "dst_ip": dst_ip,
        "dst_port": dst_port,
        "protocol": protocol
    }

def classify_log_entry(entry):
    """
    Classifica uma entrada de log com base em regras predefinidas
    """
    # Lista de portas sens√≠veis
    sensitive_ports = ["22", "3389", "21", "23", "445", "1433", "3306", "5432"]
    
    # Lista de IPs internos (simplificada)
    internal_networks = ["10.", "192.168.", "172.16."]
    
    # Verificando se √© um IP interno
    is_internal_src = any(entry["src_ip"].startswith(net) for net in internal_networks)
    is_internal_dst = any(entry["dst_ip"].startswith(net) for net in internal_networks)
    
    # Regras de classifica√ß√£o
    
    # Regra 1: Bloqueios de tentativas de acesso a portas sens√≠veis de fora para dentro
    if (entry["action"] == "BLOCK" and 
        not is_internal_src and 
        is_internal_dst and 
        entry["dst_port"] in sensitive_ports):
        return "Cr√≠tica", "Poss√≠vel tentativa de invas√£o em porta sens√≠vel"
    
    # Regra 2: M√∫ltiplos bloqueios do mesmo IP externo
    if (entry["action"] == "BLOCK" and 
        not is_internal_src and 
        entry["src_ip"] in high_frequency_ips):
        return "Cr√≠tica", "M√∫ltiplas tentativas bloqueadas do mesmo IP externo"
    
    # Regra 3: Tr√°fego permitido de fora para dentro em portas sens√≠veis
    if (entry["action"] == "ALLOW" and 
        not is_internal_src and 
        is_internal_dst and 
        entry["dst_port"] in sensitive_ports):
        return "Alerta", "Acesso externo permitido a porta sens√≠vel"
    
    # Regra 4: Tr√°fego bloqueado de dentro para fora
    if (entry["action"] == "BLOCK" and 
        is_internal_src and 
        not is_internal_dst):
        return "Aviso", "Tr√°fego de sa√≠da bloqueado"
    
    # Regra 5: Qualquer outro bloqueio
    if entry["action"] == "BLOCK":
        return "Aviso", "Tr√°fego bloqueado"
    
    # Regra 6: Qualquer outro permitido
    return "Informativa", "Tr√°fego permitido"

# Lista de entradas de log (simuladas)
firewall_logs = [
    "2023-05-10 08:15:23 BLOCK 203.0.113.42:39152 -> 10.0.0.15:22 TCP",
    "2023-05-10 08:16:45 BLOCK 203.0.113.42:39153 -> 10.0.0.15:22 TCP",
    "2023-05-10 08:17:12 BLOCK 203.0.113.42:39154 -> 10.0.0.15:22 TCP",
    "2023-05-10 09:23:15 ALLOW 10.0.0.23:52125 -> 172.217.168.238:443 TCP",
    "2023-05-10 10:45:32 ALLOW 192.168.1.5:58921 -> 192.168.1.1:53 UDP",
    "2023-05-10 11:02:18 BLOCK 10.0.0.12:45678 -> 198.51.100.75:80 TCP",
    "2023-05-10 11:15:42 ALLOW 198.51.100.30:443 -> 10.0.0.5:52126 TCP",
    "2023-05-10 12:34:56 BLOCK 198.51.100.42:12345 -> 10.0.0.10:3389 TCP",
    "2023-05-10 13:45:23 ALLOW 10.0.0.15:53124 -> 198.51.100.200:443 TCP",
    "2023-05-10 14:22:11 ALLOW 192.168.1.100:58922 -> 192.168.1.1:53 UDP",
    "2023-05-10 15:18:45 BLOCK 203.0.113.100:45678 -> 10.0.0.20:22 TCP",
    "2023-05-10 16:30:12 ALLOW 10.0.0.30:60234 -> 198.51.100.150:80 TCP",
    "2023-05-10 17:45:33 BLOCK 198.51.100.200:33218 -> 10.0.0.25:445 TCP",
    "2023-05-10 18:12:48 ALLOW 10.0.0.40:52127 -> 198.51.100.10:443 TCP",
    "2023-05-10 19:23:59 BLOCK 10.0.0.18:48765 -> 203.0.113.10:21 TCP"
]

# Pr√©-processamento para identificar IPs de alta frequ√™ncia
ip_frequency = {}
for log in firewall_logs:
    parsed = parse_log_entry(log)
    src_ip = parsed["src_ip"]
    ip_frequency[src_ip] = ip_frequency.get(src_ip, 0) + 1

# IPs que aparecem mais de 2 vezes
high_frequency_ips = [ip for ip, count in ip_frequency.items() if count > 2]

# Analisando e classificando os logs
parsed_logs = []
classification_counts = {"Cr√≠tica": 0, "Alerta": 0, "Aviso": 0, "Informativa": 0}
critical_events = []

for log in firewall_logs:
    parsed = parse_log_entry(log)
    severity, reason = classify_log_entry(parsed)
    
    parsed["severity"] = severity
    parsed["reason"] = reason
    parsed_logs.append(parsed)
    
    classification_counts[severity] += 1
    
    if severity == "Cr√≠tica":
        critical_events.append(parsed)

# Gerando relat√≥rio
print("Relat√≥rio de An√°lise de Logs de Firewall")
print("=======================================")

print("\nResumo por Categoria:")
for category, count in classification_counts.items():
    print(f"{category}: {count} eventos")

print("\nEventos Cr√≠ticos:")
if critical_events:
    for event in critical_events:
        print(f"- {event['timestamp']} | {event['src_ip']}:{event['src_port']} -> {event['dst_ip']}:{event['dst_port']} | {event['reason']}")
else:
    print("Nenhum evento cr√≠tico identificado.")

print("\nDistribui√ß√£o de A√ß√µes:")
allow_count = sum(1 for log in parsed_logs if log["action"] == "ALLOW")
block_count = sum(1 for log in parsed_logs if log["action"] == "BLOCK")
print(f"ALLOW: {allow_count} ({allow_count/len(parsed_logs)*100:.1f}%)")
print(f"BLOCK: {block_count} ({block_count/len(parsed_logs)*100:.1f}%)")

print("\nTop 3 IPs de Origem:")
ip_counts = {}
for log in parsed_logs:
    src_ip = log["src_ip"]
    ip_counts[src_ip] = ip_counts.get(src_ip, 0) + 1

top_ips = sorted(ip_counts.items(), key=lambda x: x[1], reverse=True)[:3]
for ip, count in top_ips:
    print(f"{ip}: {count} eventos")</code></pre>
            </div>
            
            <div class="exercise">
                <h4>Exerc√≠cio 3: Verificador de Configura√ß√£o de Roteador</h4>
                <p>Crie um script Python que analise uma configura√ß√£o de roteador Cisco e verifique se ela atende a determinados requisitos de seguran√ßa. O script deve:</p>
                <ol>
                    <li>Analisar uma configura√ß√£o fornecida como uma string multi-linha</li>
                    <li>Verificar a presen√ßa de configura√ß√µes de seguran√ßa essenciais (senha de enable, acesso SSH, ACLs, etc.)</li>
                    <li>Gerar um relat√≥rio de conformidade, indicando quais requisitos foram atendidos e quais n√£o foram</li>
                    <li>Calcular uma pontua√ß√£o geral de seguran√ßa (porcentagem de requisitos atendidos)</li>
                </ol>
            </div>
            
            <div class="solution">
                <h4>Solu√ß√£o do Exerc√≠cio 3:</h4>
                <pre><code>#!/usr/bin/env python3
# Verificador de Configura√ß√£o de Roteador

def check_router_security(config):
    """
    Analisa uma configura√ß√£o de roteador Cisco e verifica requisitos de seguran√ßa
    """
    # Lista de requisitos de seguran√ßa a verificar
    security_requirements = [
        {
            "name": "Senha de Enable Criptografada",
            "check": lambda c: "enable secret" in c,
            "importance": "Alta",
            "recommendation": "Configure 'enable secret' para proteger o acesso privilegiado"
        },
        {
            "name": "Acesso SSH Configurado",
            "check": lambda c: "transport input ssh" in c or "transport input all" in c,
            "importance": "Alta",
            "recommendation": "Configure 'transport input ssh' nas linhas VTY"
        },
        {
            "name": "Telnet Desabilitado",
            "check": lambda c: "transport input ssh" in c and "transport input all" not in c and "transport input telnet" not in c,
            "importance": "Alta",
            "recommendation": "Desabilite telnet usando 'transport input ssh' (n√£o use 'transport input all')"
        },
        {
            "name": "Timeout de Login Configurado",
            "check": lambda c: "exec-timeout" in c,
            "importance": "M√©dia",
            "recommendation": "Configure 'exec-timeout' para encerrar sess√µes inativas"
        },
        {
            "name": "Banner de Login Configurado",
            "check": lambda c: "banner login" in c or "banner motd" in c,
            "importance": "Baixa",
            "recommendation": "Configure um banner de aviso usando 'banner login' ou 'banner motd'"
        },
        {
            "name": "Servi√ßo de Senha Criptografada",
            "check": lambda c: "service password-encryption" in c,
            "importance": "M√©dia",
            "recommendation": "Ative 'service password-encryption' para criptografar senhas em texto claro"
        },
        {
            "name": "ACLs Aplicadas",
            "check": lambda c: "access-group" in c,
            "importance": "Alta",
            "recommendation": "Aplique ACLs para restringir o acesso usando 'ip access-group'"
        },
        {
            "name": "NTP Configurado",
            "check": lambda c: "ntp server" in c,
            "importance": "M√©dia",
            "recommendation": "Configure NTP para sincroniza√ß√£o precisa de tempo"
        },
        {
            "name": "Logging Configurado",
            "check": lambda c: "logging" in c and not only_console_logging(c),
            "importance": "M√©dia",
            "recommendation": "Configure logging para um servidor syslog externo"
        },
        {
            "name": "SNMP v3 Configurado",
            "check": lambda c: "snmp-server group" in c and "v3" in c,
            "importance": "M√©dia",
            "recommendation": "Use SNMPv3 com autentica√ß√£o e criptografia"
        },
        {
            "name": "Servi√ßos Desnecess√°rios Desabilitados",
            "check": lambda c: "no service" in c,
            "importance": "M√©dia",
            "recommendation": "Desabilite servi√ßos desnecess√°rios como 'no service finger', 'no service pad', etc."
        },
        {
            "name": "AAA Configurado",
            "check": lambda c: "aaa new-model" in c,
            "importance": "Alta",
            "recommendation": "Configure AAA para autentica√ß√£o, autoriza√ß√£o e accounting"
        }
    ]
    
    # Normaliza a configura√ß√£o (remove espa√ßos extras, converte para min√∫sculas)
    normalized_config = config.lower()
    
    # Verifica cada requisito
    results = []
    for req in security_requirements:
        compliant = req["check"](normalized_config)
        results.append({
            "name": req["name"],
            "compliant": compliant,
            "importance": req["importance"],
            "recommendation": req["recommendation"] if not compliant else None
        })
    
    # Calcula pontua√ß√£o geral
    total_reqs = len(results)
    compliant_reqs = sum(1 for r in results if r["compliant"])
    security_score = (compliant_reqs / total_reqs) * 100
    
    # Calcula pontua√ß√£o ponderada (Alta = 3, M√©dia = 2, Baixa = 1)
    weights = {"Alta": 3, "M√©dia": 2, "Baixa": 1}
    weighted_total = sum(weights[r["importance"]] for r in results)
    weighted_compliant = sum(weights[r["importance"]] for r in results if r["compliant"])
    weighted_score = (weighted_compliant / weighted_total) * 100 if weighted_total > 0 else 0
    
    return {
        "results": results,
        "security_score": security_score,
        "weighted_score": weighted_score,
        "total_requirements": total_reqs,
        "compliant_requirements": compliant_reqs
    }

def only_console_logging(config):
    """
    Verifica se apenas logging de console est√° configurado
    """
    return "logging console" in config and "logging host" not in config and "logging buffered" not in config

# Exemplo de configura√ß√£o de roteador
router_config = """
hostname Router1
!
service password-encryption
service timestamps debug datetime msec
service timestamps log datetime msec
!
no service finger
!
enable secret 5 $1$mERr$hx5rVt7rPNoS4wqbXKX7m0
!
ip domain-name example.com
ip name-server 8.8.8.8
!
username admin privilege 15 secret 5 $1$mERr$hx5rVt7rPNoS4wqbXKX7m0
!
interface GigabitEthernet0/0
 description WAN Interface
 ip address 203.0.113.1 255.255.255.0
 ip access-group 100 in
 no shutdown
!
interface GigabitEthernet0/1
 description LAN Interface
 ip address 192.168.1.1 255.255.255.0
 no shutdown
!
ip access-list extended 100
 deny ip any host 192.168.1.1
 permit ip any any
!
logging buffered 16384
logging host 192.168.1.100
!
ntp server 192.168.1.200
!
line con 0
 exec-timeout 5 0
 logging synchronous
!
line vty 0 4
 exec-timeout 10 0
 login local
 transport input ssh
!
banner motd ^C
WARNING: Unauthorized access is prohibited!
^C
!
end
"""

# Analisando a configura√ß√£o
security_analysis = check_router_security(router_config)

# Gerando relat√≥rio
print("Relat√≥rio de Seguran√ßa de Configura√ß√£o de Roteador")
print("=================================================")

print(f"\nPontua√ß√£o de Seguran√ßa: {security_analysis['security_score']:.1f}%")
print(f"Pontua√ß√£o Ponderada: {security_analysis['weighted_score']:.1f}%")
print(f"Requisitos Atendidos: {security_analysis['compliant_requirements']} de {security_analysis['total_requirements']}")

print("\nDetalhes por Requisito:")
print("-----------------------")

# Agrupando por import√¢ncia
importance_groups = {"Alta": [], "M√©dia": [], "Baixa": []}
for result in security_analysis["results"]:
    importance_groups[result["importance"]].append(result)

# Exibindo resultados por import√¢ncia
for importance in ["Alta", "M√©dia", "Baixa"]:
    print(f"\n[{importance} Import√¢ncia]")
    for result in importance_groups[importance]:
        status = "‚úÖ" if result["compliant"] else "‚ùå"
        print(f"{status} {result['name']}")
        if not result["compliant"]:
            print(f"   Recomenda√ß√£o: {result['recommendation']}")

# Resumo de recomenda√ß√µes cr√≠ticas
print("\nRecomenda√ß√µes Cr√≠ticas:")
print("----------------------")
critical_recommendations = [r for r in security_analysis["results"] 
                          if not r["compliant"] and r["importance"] == "Alta"]

if critical_recommendations:
    for rec in critical_recommendations:
        print(f"- {rec['recommendation']}")
else:
    print("Nenhuma recomenda√ß√£o cr√≠tica pendente.")

# Avalia√ß√£o geral
print("\nAvalia√ß√£o Geral:")
if security_analysis["weighted_score"] >= 90:
    print("Excelente: A configura√ß√£o atende √† maioria dos requisitos de seguran√ßa.")
elif security_analysis["weighted_score"] >= 70:
    print("Boa: A configura√ß√£o atende a muitos requisitos, mas h√° espa√ßo para melhorias.")
elif security_analysis["weighted_score"] >= 50:
    print("Regular: A configura√ß√£o atende a alguns requisitos, mas precisa de melhorias significativas.")
else:
    print("Insuficiente: A configura√ß√£o n√£o atende √† maioria dos requisitos de seguran√ßa e precisa de aten√ß√£o imediata.")</code></pre>
            </div>
        </section>

        <section id="avaliacao">
            <h2>Avalia√ß√£o do M√≥dulo</h2>
            
            <div class="assessment">
                <h4>Quiz de Conhecimentos</h4>
                <p>Responda √†s seguintes perguntas para testar seu conhecimento sobre os conceitos apresentados neste m√≥dulo:</p>
                
                <ol>
                    <li>Qual √© a diferen√ßa entre os operadores <code>==</code> e <code>=</code> em Python?</li>
                    <li>Quais s√£o os tr√™s principais operadores l√≥gicos em Python?</li>
                    <li>O que acontece se voc√™ n√£o indentar corretamente o c√≥digo dentro de uma estrutura condicional?</li>
                    <li>Como voc√™ pode verificar se uma string cont√©m uma substring em Python?</li>
                    <li>Qual √© o resultado da express√£o <code>True and False or True</code>?</li>
                    <li>Qual √© a diferen√ßa entre <code>elif</code> e <code>else if</code> em Python?</li>
                    <li>Como voc√™ pode verificar se um valor est√° dentro de um intervalo em Python?</li>
                    <li>O que √© uma estrutura condicional aninhada?</li>
                    <li>Qual operador voc√™ usaria para verificar se duas vari√°veis apontam para o mesmo objeto em mem√≥ria?</li>
                    <li>Como voc√™ pode simplificar estruturas condicionais aninhadas complexas?</li>
                </ol>
            </div>
            
            <div class="solution">
                <h4>Respostas do Quiz:</h4>
                <ol>
                    <li><strong>Diferen√ßa entre == e =:</strong> O operador <code>=</code> √© usado para atribui√ß√£o de valores a vari√°veis, enquanto <code>==</code> √© um operador de compara√ß√£o que verifica se dois valores s√£o iguais.</li>
                    <li><strong>Tr√™s principais operadores l√≥gicos:</strong> <code>and</code>, <code>or</code> e <code>not</code>.</li>
                    <li><strong>Indenta√ß√£o incorreta:</strong> Python usa indenta√ß√£o para definir blocos de c√≥digo. Se a indenta√ß√£o estiver incorreta, ocorrer√° um erro de sintaxe (IndentationError) ou o c√≥digo pode ser executado de forma inesperada, pois a indenta√ß√£o determina quais instru√ß√µes pertencem a qual bloco.</li>
                    <li><strong>Verificar substring:</strong> Voc√™ pode usar o operador <code>in</code>. Por exemplo: <code>"ip" in "show ip interface brief"</code> retornar√° <code>True</code>.</li>
                    <li><strong>Resultado da express√£o:</strong> <code>True and False or True</code> resulta em <code>True</code>. Primeiro, <code>True and False</code> √© avaliado como <code>False</code>, depois <code>False or True</code> √© avaliado como <code>True</code>.</li>
                    <li><strong>Diferen√ßa entre elif e else if:</strong> <code>elif</code> √© uma palavra-chave √∫nica em Python que significa "else if". Em Python, n√£o existe a constru√ß√£o <code>else if</code> como em outras linguagens; usa-se <code>elif</code> para verificar condi√ß√µes adicionais ap√≥s um <code>if</code>.</li>
                    <li><strong>Verificar valor em intervalo:</strong> Voc√™ pode usar compara√ß√µes encadeadas. Por exemplo: <code>0 <= x <= 10</code> verifica se x est√° entre 0 e 10 (inclusive).</li>
                    <li><strong>Estrutura condicional aninhada:</strong> √â uma estrutura condicional dentro de outra estrutura condicional. Ocorre quando voc√™ tem um <code>if</code>, <code>elif</code> ou <code>else</code> dentro de outro bloco <code>if</code>, <code>elif</code> ou <code>else</code>.</li>
                    <li><strong>Verificar mesmo objeto:</strong> O operador <code>is</code> verifica se duas vari√°veis apontam para o mesmo objeto em mem√≥ria.</li>
                    <li><strong>Simplificar estruturas aninhadas:</strong> Voc√™ pode simplificar estruturas condicionais aninhadas usando operadores l√≥gicos para combinar condi√ß√µes, usando express√µes condicionais (operador tern√°rio), refatorando o c√≥digo em fun√ß√µes menores, ou usando estruturas de dados como dicion√°rios para mapear condi√ß√µes a a√ß√µes.</li>
                </ol>
            </div>
            
            <div class="assessment">
                <h4>Projeto Pr√°tico</h4>
                <p>Desenvolva um script Python que implemente um sistema de monitoramento de rede b√°sico. O script deve:</p>
                
                <ol>
                    <li>Ler uma lista de dispositivos de rede (nome, IP, tipo, import√¢ncia) de um arquivo ou definida no c√≥digo</li>
                    <li>Verificar a conectividade de cada dispositivo (pode simular isso para fins do exerc√≠cio)</li>
                    <li>Implementar uma l√≥gica de decis√£o que determine diferentes a√ß√µes com base no tipo de dispositivo, sua import√¢ncia e seu estado atual</li>
                    <li>Gerar alertas com diferentes n√≠veis de severidade dependendo da situa√ß√£o</li>
                    <li>Produzir um relat√≥rio resumido do estado da rede</li>
                </ol>
                
                <p>Use estruturas condicionais, operadores l√≥gicos e estruturas aninhadas conforme necess√°rio para implementar a l√≥gica de decis√£o. Tente criar um sistema que seja flex√≠vel e possa ser facilmente expandido para incluir mais tipos de dispositivos e regras.</p>
            </div>
        </section>

        <section id="referencias">
            <h2>Refer√™ncias e Recursos Adicionais</h2>
            
            <div class="references">
                <h3>Documenta√ß√£o Oficial</h3>
                <ul>
                    <li><a href="https://docs.python.org/3/tutorial/controlflow.html" target="_blank">Tutorial Python: Estruturas de Controle de Fluxo</a></li>
                    <li><a href="https://docs.python.org/3/library/stdtypes.html#boolean-operations-and-or-not" target="_blank">Opera√ß√µes Booleanas em Python</a></li>
                    <li><a href="https://docs.python.org/3/reference/expressions.html#comparisons" target="_blank">Express√µes de Compara√ß√£o em Python</a></li>
                </ul>
                
                <h3>Livros Recomendados</h3>
                <ul>
                    <li>Eric Matthes - "Python Crash Course" (Cap√≠tulo sobre Estruturas Condicionais)</li>
                    <li>Al Sweigart - "Automate the Boring Stuff with Python" (Cap√≠tulo sobre Controle de Fluxo)</li>
                    <li>Kirk Byers - "Python for Network Engineers" (Se√ß√µes sobre Tomada de Decis√£o em Scripts de Rede)</li>
                </ul>
                
                <h3>Recursos Online</h3>
                <ul>
                    <li><a href="https://realpython.com/python-conditional-statements/" target="_blank">Real Python: Conditional Statements in Python</a></li>
                    <li><a href="https://www.w3schools.com/python/python_conditions.asp" target="_blank">W3Schools: Python Conditions</a></li>
                    <li><a href="https://pynet.twb-tech.com/blog/python/if-statement.html" target="_blank">PyNet: Python If Statement</a></li>
                </ul>
                
                <h3>Recursos Espec√≠ficos para Redes</h3>
                <ul>
                    <li><a href="https://developer.cisco.com/learning/modules/programming-fundamentals/python-part1/step/1" target="_blank">Cisco DevNet: Python Programming for Network Engineers</a></li>
                    <li><a href="https://www.ciscolive.com/c/dam/r/ciscolive/us/docs/2018/pdf/DEVNET-1695.pdf" target="_blank">Cisco Live: Network Programmability with Python</a></li>
                    <li><a href="https://github.com/ktbyers/netmiko/tree/develop/examples" target="_blank">Exemplos do Netmiko no GitHub</a></li>
                </ul>
            </div>
        </section>
        
        <div class="navigation-buttons">
            <a href="modulo2.html" class="btn">‚Üê M√≥dulo Anterior: Vari√°veis e Tipos de Dados</a>
            <a href="modulo4.html" class="btn">Pr√≥ximo M√≥dulo: La√ßos de Repeti√ß√£o ‚Üí</a>
        </div>
    </main>

    <footer>
        <p>&copy; 2025 Curso de Python para Profissionais de Redes Cisco. Todos os direitos reservados.</p>
    </footer>
</body>
</html>
