<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Módulo 4: Laços de Repetição - Curso de Python para Redes Cisco</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <h1>Módulo 4: Laços de Repetição</h1>
        <p>Curso de Python para Profissionais de Redes Cisco</p>
    </header>

    <nav>
        <ul>
            <li><a href="index.html">Página Inicial</a></li>
            <li><a href="modulo3.html">← Módulo Anterior</a></li>
            <li><a href="#while">Laços While</a></li>
            <li><a href="#for">Laços For</a></li>
            <li><a href="#break-continue">Break e Continue</a></li>
            <li><a href="#list-comprehension">Compreensão de Listas</a></li>
            <li><a href="#exercicios">Exercícios</a></li>
            <li><a href="#avaliacao">Avaliação</a></li>
            <li><a href="#referencias">Referências</a></li>
            <li><a href="modulo5.html">Próximo Módulo →</a></li>
        </ul>
    </nav>

    <main>
        <section id="introducao">
            <h2>Introdução aos Laços de Repetição</h2>
            
            <p>Os laços de repetição, também conhecidos como loops, são estruturas fundamentais em programação que permitem executar um bloco de código múltiplas vezes. Em automação de redes, essas estruturas são essenciais para processar múltiplos dispositivos, interfaces ou configurações de forma eficiente.</p>
            
            <p>Imagine que você precisa verificar o status de 50 switches em sua rede. Sem laços de repetição, você teria que escrever o mesmo código 50 vezes, uma para cada switch. Com laços, você pode escrever o código uma vez e fazer com que ele seja executado para cada dispositivo automaticamente.</p>
            
            <p>Neste módulo, exploraremos os dois principais tipos de laços em Python: <code>while</code> e <code>for</code>. Também veremos como controlar o fluxo dentro dos laços usando <code>break</code> e <code>continue</code>, e aprenderemos sobre compreensão de listas, uma poderosa funcionalidade do Python para criar listas de forma concisa.</p>
            
            <div class="note">
                <h4>Importância para Profissionais de Redes:</h4>
                <p>Os laços de repetição são particularmente importantes para profissionais de redes porque permitem automatizar tarefas repetitivas em múltiplos dispositivos. Por exemplo, você pode criar scripts que configuram dezenas de switches simultaneamente, monitoram o status de todas as interfaces de um roteador, ou verificam a conectividade de todos os dispositivos em uma sub-rede.</p>
            </div>
        </section>

        <section id="while">
            <h2>Laços While</h2>
            
            <p>O laço <code>while</code> executa um bloco de código repetidamente enquanto uma condição específica for verdadeira. É especialmente útil quando você não sabe antecipadamente quantas iterações serão necessárias.</p>
            
            <h3>Sintaxe Básica</h3>
            
            <pre><code># Sintaxe básica do laço while
while condição:
    # Bloco de código a ser executado
    # enquanto a condição for verdadeira</code></pre>
            
            <p>O fluxo de execução de um laço <code>while</code> é o seguinte:</p>
            
            <ol>
                <li>A condição é avaliada</li>
                <li>Se a condição for verdadeira, o bloco de código é executado</li>
                <li>Após a execução do bloco, a condição é avaliada novamente</li>
                <li>Este processo continua até que a condição se torne falsa</li>
            </ol>
            
            <h3>Exemplo Simples</h3>
            
            <pre><code># Contagem regressiva
countdown = 5

while countdown > 0:
    print(f"Contagem regressiva: {countdown}")
    countdown -= 1  # Decrementa o contador

print("Lançamento!")</code></pre>
            
            <p>Saída:</p>
            
            <pre>Contagem regressiva: 5
Contagem regressiva: 4
Contagem regressiva: 3
Contagem regressiva: 2
Contagem regressiva: 1
Lançamento!</pre>
            
            <h3>Laço While com Condição Composta</h3>
            
            <p>Você pode usar operadores lógicos para criar condições mais complexas:</p>
            
            <pre><code># Monitoramento de utilização de CPU
import time
import random

def get_cpu_utilization():
    # Simulação: retorna um valor aleatório entre 0 e 100
    return random.randint(0, 100)

threshold = 80
duration = 0
max_duration = 30  # segundos

print("Iniciando monitoramento de CPU...")

while get_cpu_utilization() < threshold and duration < max_duration:
    current_cpu = get_cpu_utilization()
    print(f"Utilização atual de CPU: {current_cpu}%")
    duration += 5
    time.sleep(5)  # Pausa por 5 segundos

if duration >= max_duration:
    print("Monitoramento concluído. Nenhum pico de CPU detectado.")
else:
    print(f"Alerta! Utilização de CPU acima de {threshold}%")</code></pre>
            
            <h3>Laço While Infinito com Condição de Saída</h3>
            
            <p>Às vezes, é útil criar um laço que continua indefinidamente até que uma condição específica seja atendida:</p>
            
            <pre><code># Monitoramento contínuo com condição de saída
import time

def check_device_status(device_ip):
    # Simulação: alternando entre True e False
    import random
    return random.choice([True, False])

device_ip = "192.168.1.1"
attempts = 0

print(f"Monitorando dispositivo {device_ip}...")

while True:  # Laço infinito
    is_online = check_device_status(device_ip)
    attempts += 1
    
    if is_online:
        print(f"Dispositivo {device_ip} está online. Status OK.")
    else:
        print(f"Dispositivo {device_ip} está offline! Tentativa {attempts}")
        
        if attempts >= 3:
            print("Número máximo de tentativas atingido. Enviando alerta!")
            break  # Sai do laço
    
    time.sleep(2)  # Pausa por 2 segundos

print("Monitoramento encerrado.")</code></pre>
            
            <div class="note">
                <h4>Cuidado com Laços Infinitos:</h4>
                <p>Ao usar laços <code>while</code>, certifique-se de que a condição eventualmente se tornará falsa ou que haja uma instrução <code>break</code> para sair do laço. Caso contrário, você criará um laço infinito que pode travar seu programa.</p>
            </div>
            
            <h3>Aplicação em Redes: Verificação de Conectividade</h3>
            
            <p>Vamos ver um exemplo prático de como usar laços <code>while</code> para verificar a conectividade de um dispositivo de rede:</p>
            
            <pre><code>import subprocess
import time

def ping_device(ip_address):
    """
    Verifica se um dispositivo está acessível via ping
    Retorna True se o ping for bem-sucedido, False caso contrário
    """
    try:
        # Executa o comando ping (funciona em Windows e Linux)
        result = subprocess.call(
            ["ping", "-c", "1", "-W", "1", ip_address],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL
        )
        return result == 0
    except Exception:
        return False

def wait_for_device(ip_address, timeout=60, interval=5):
    """
    Aguarda até que um dispositivo esteja acessível ou até que o timeout seja atingido
    """
    print(f"Aguardando dispositivo {ip_address} ficar online...")
    
    start_time = time.time()
    elapsed_time = 0
    
    while elapsed_time < timeout:
        if ping_device(ip_address):
            print(f"Dispositivo {ip_address} está online após {elapsed_time:.1f} segundos!")
            return True
        
        print(f"Dispositivo {ip_address} ainda offline. Tentando novamente em {interval} segundos...")
        time.sleep(interval)
        elapsed_time = time.time() - start_time
    
    print(f"Timeout atingido. Dispositivo {ip_address} continua offline após {timeout} segundos.")
    return False

# Exemplo de uso
router_ip = "192.168.1.1"
if wait_for_device(router_ip, timeout=30, interval=5):
    print("Prosseguindo com a configuração do roteador...")
else:
    print("Não foi possível conectar ao roteador. Verifique a conectividade física.")</code></pre>
            
            <p>Este exemplo demonstra como usar um laço <code>while</code> para aguardar que um dispositivo de rede fique online, com um timeout para evitar espera infinita. Esta é uma técnica comum em scripts de automação de rede, especialmente após reiniciar dispositivos ou aplicar configurações que podem causar interrupções temporárias.</p>
        </section>

        <section id="for">
            <h2>Laços For e Função range()</h2>
            
            <p>O laço <code>for</code> em Python é usado para iterar sobre uma sequência (como uma lista, tupla, dicionário, conjunto ou string) ou outros objetos iteráveis. É especialmente útil quando você sabe antecipadamente sobre quais elementos deseja iterar.</p>
            
            <h3>Sintaxe Básica</h3>
            
            <pre><code># Sintaxe básica do laço for
for elemento in sequência:
    # Bloco de código a ser executado
    # para cada elemento na sequência</code></pre>
            
            <h3>Iterando sobre uma Lista</h3>
            
            <pre><code># Lista de dispositivos de rede
devices = ["Router1", "Switch1", "Firewall", "AP1", "Switch2"]

for device in devices:
    print(f"Verificando dispositivo: {device}")

# Saída:
# Verificando dispositivo: Router1
# Verificando dispositivo: Switch1
# Verificando dispositivo: Firewall
# Verificando dispositivo: AP1
# Verificando dispositivo: Switch2</code></pre>
            
            <h3>Iterando sobre uma String</h3>
            
            <pre><code># Verificando caracteres em um endereço MAC
mac_address = "00:1A:2B:3C:4D:5E"

for char in mac_address:
    if char == ":":
        print("Separador encontrado")
    else:
        print(f"Caractere hexadecimal: {char}")

# Saída parcial:
# Caractere hexadecimal: 0
# Caractere hexadecimal: 0
# Separador encontrado
# Caractere hexadecimal: 1
# Caractere hexadecimal: A
# Separador encontrado
# ...</code></pre>
            
            <h3>A Função range()</h3>
            
            <p>A função <code>range()</code> gera uma sequência de números, o que a torna muito útil em laços <code>for</code> quando você precisa executar um código um número específico de vezes.</p>
            
            <pre><code># range(stop) - gera números de 0 até stop-1
for i in range(5):
    print(i)
# Saída: 0, 1, 2, 3, 4

# range(start, stop) - gera números de start até stop-1
for i in range(10, 15):
    print(i)
# Saída: 10, 11, 12, 13, 14

# range(start, stop, step) - gera números de start até stop-1 com incremento step
for i in range(0, 10, 2):
    print(i)
# Saída: 0, 2, 4, 6, 8</code></pre>
            
            <h3>Enumerando Elementos</h3>
            
            <p>A função <code>enumerate()</code> é útil quando você precisa do índice e do valor de cada elemento durante a iteração:</p>
            
            <pre><code># Enumerando dispositivos
devices = ["Router1", "Switch1", "Firewall", "AP1"]

for index, device in enumerate(devices):
    print(f"Dispositivo {index + 1}: {device}")

# Saída:
# Dispositivo 1: Router1
# Dispositivo 2: Switch1
# Dispositivo 3: Firewall
# Dispositivo 4: AP1</code></pre>
            
            <h3>Iterando sobre Múltiplas Listas Simultaneamente</h3>
            
            <p>A função <code>zip()</code> permite iterar sobre múltiplas sequências ao mesmo tempo:</p>
            
            <pre><code># Associando dispositivos e IPs
devices = ["Router1", "Switch1", "Firewall", "AP1"]
ips = ["192.168.1.1", "192.168.1.2", "192.168.1.254", "192.168.1.100"]

for device, ip in zip(devices, ips):
    print(f"Dispositivo: {device}, IP: {ip}")

# Saída:
# Dispositivo: Router1, IP: 192.168.1.1
# Dispositivo: Switch1, IP: 192.168.1.2
# Dispositivo: Firewall, IP: 192.168.1.254
# Dispositivo: AP1, IP: 192.168.1.100</code></pre>
            
            <h3>Aplicação em Redes: Monitoramento de Múltiplos Dispositivos</h3>
            
            <p>Vamos ver um exemplo prático de como usar laços <code>for</code> para monitorar múltiplos dispositivos de rede:</p>
            
            <pre><code>import subprocess
import time
from datetime import datetime

def check_device(ip, name):
    """
    Verifica se um dispositivo está acessível via ping
    Retorna um dicionário com os resultados
    """
    try:
        # Registra o tempo de início
        start_time = time.time()
        
        # Executa o comando ping
        result = subprocess.call(
            ["ping", "-c", "2", "-W", "1", ip],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL
        )
        
        # Calcula o tempo de resposta
        response_time = time.time() - start_time
        
        # Prepara o resultado
        status = "UP" if result == 0 else "DOWN"
        return {
            "name": name,
            "ip": ip,
            "status": status,
            "response_time": response_time if status == "UP" else None
        }
    except Exception as e:
        return {
            "name": name,
            "ip": ip,
            "status": "ERROR",
            "response_time": None,
            "error": str(e)
        }

# Lista de dispositivos para monitorar
network_devices = [
    {"name": "Core Router", "ip": "192.168.1.1", "type": "router"},
    {"name": "Distribution Switch", "ip": "192.168.1.2", "type": "switch"},
    {"name": "Access Switch 1", "ip": "192.168.1.3", "type": "switch"},
    {"name": "Access Switch 2", "ip": "192.168.1.4", "type": "switch"},
    {"name": "Firewall", "ip": "192.168.1.254", "type": "firewall"},
    {"name": "Wireless AP 1", "ip": "192.168.2.10", "type": "ap"},
    {"name": "Wireless AP 2", "ip": "192.168.2.11", "type": "ap"}
]

# Monitoramento dos dispositivos
print(f"Iniciando monitoramento de rede em {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
print("-" * 80)

results = []
for device in network_devices:
    print(f"Verificando {device['name']} ({device['ip']})...")
    result = check_device(device['ip'], device['name'])
    results.append(result)

# Exibindo resultados
print("\nResultados do Monitoramento:")
print("-" * 80)
print(f"{'Dispositivo':<20} {'IP':<15} {'Status':<8} {'Tempo de Resposta':<20}")
print("-" * 80)

for result in results:
    response_time = f"{result['response_time']*1000:.2f} ms" if result['response_time'] else "N/A"
    status_display = result['status']
    
    # Formatação colorida (simulada com texto)
    if status_display == "UP":
        status_display = "UP ✓"
    elif status_display == "DOWN":
        status_display = "DOWN ✗"
    else:
        status_display = "ERROR !"
    
    print(f"{result['name']:<20} {result['ip']:<15} {status_display:<8} {response_time:<20}")

# Estatísticas
up_count = sum(1 for r in results if r['status'] == "UP")
down_count = sum(1 for r in results if r['status'] == "DOWN")
error_count = sum(1 for r in results if r['status'] == "ERROR")

print("-" * 80)
print(f"Total de dispositivos: {len(results)}")
print(f"Dispositivos online: {up_count} ({up_count/len(results)*100:.1f}%)")
print(f"Dispositivos offline: {down_count} ({down_count/len(results)*100:.1f}%)")
print(f"Erros: {error_count} ({error_count/len(results)*100:.1f}%)")

# Tempo médio de resposta para dispositivos online
online_devices = [r for r in results if r['status'] == "UP"]
if online_devices:
    avg_response = sum(d['response_time'] for d in online_devices) / len(online_devices)
    print(f"Tempo médio de resposta: {avg_response*1000:.2f} ms")</code></pre>
            
            <p>Este exemplo demonstra como usar um laço <code>for</code> para monitorar múltiplos dispositivos de rede, coletando informações sobre seu status e tempo de resposta. O script itera sobre uma lista de dispositivos, verifica cada um e gera um relatório com os resultados e estatísticas.</p>
            
            <div class="note">
                <h4>Dica para Profissionais de Redes:</h4>
                <p>Ao trabalhar com grandes listas de dispositivos, considere usar processamento paralelo (como a biblioteca <code>concurrent.futures</code>) para verificar múltiplos dispositivos simultaneamente, reduzindo significativamente o tempo total de execução.</p>
            </div>
        </section>

        <section id="break-continue">
            <h2>Comandos break e continue</h2>
            
            <p>Os comandos <code>break</code> e <code>continue</code> permitem controlar o fluxo de execução dentro de laços, oferecendo mais flexibilidade na forma como você itera sobre os elementos.</p>
            
            <h3>O Comando break</h3>
            
            <p>O comando <code>break</code> é usado para sair completamente de um laço antes que a condição normal de saída seja atingida:</p>
            
            <pre><code># Exemplo de break em um laço for
devices = ["Router1", "Switch1", "Firewall", "AP1", "Switch2"]

for device in devices:
    print(f"Verificando dispositivo: {device}")
    
    if device == "Firewall":
        print("Firewall encontrado! Interrompendo verificação.")
        break  # Sai do laço
    
    print("Verificação concluída para este dispositivo.")

print("Processo finalizado.")

# Saída:
# Verificando dispositivo: Router1
# Verificação concluída para este dispositivo.
# Verificando dispositivo: Switch1
# Verificação concluída para este dispositivo.
# Verificando dispositivo: Firewall
# Firewall encontrado! Interrompendo verificação.
# Processo finalizado.</code></pre>
            
            <h3>O Comando continue</h3>
            
            <p>O comando <code>continue</code> é usado para pular o restante do código no laço atual e avançar para a próxima iteração:</p>
            
            <pre><code># Exemplo de continue em um laço for
devices = ["Router1", "Switch1", "Firewall", "AP1", "Switch2"]

for device in devices:
    print(f"Verificando dispositivo: {device}")
    
    if device.startswith("Switch"):
        print("Dispositivo é um switch. Pulando verificação detalhada.")
        continue  # Pula para a próxima iteração
    
    print("Realizando verificação detalhada...")
    print("Verificação concluída para este dispositivo.")

print("Processo finalizado.")

# Saída:
# Verificando dispositivo: Router1
# Realizando verificação detalhada...
# Verificação concluída para este dispositivo.
# Verificando dispositivo: Switch1
# Dispositivo é um switch. Pulando verificação detalhada.
# Verificando dispositivo: Firewall
# Realizando verificação detalhada...
# Verificação concluída para este dispositivo.
# Verificando dispositivo: AP1
# Realizando verificação detalhada...
# Verificação concluída para este dispositivo.
# Verificando dispositivo: Switch2
# Dispositivo é um switch. Pulando verificação detalhada.
# Processo finalizado.</code></pre>
            
            <h3>Uso em Laços While</h3>
            
            <p>Os comandos <code>break</code> e <code>continue</code> também são muito úteis em laços <code>while</code>:</p>
            
            <pre><code># Exemplo de break em um laço while
import random

max_attempts = 10
attempt = 0

while True:  # Laço infinito
    attempt += 1
    print(f"Tentativa {attempt} de {max_attempts}")
    
    # Simula uma verificação de conectividade
    success = random.random() > 0.7  # 30% de chance de sucesso
    
    if success:
        print("Conexão estabelecida com sucesso!")
        break  # Sai do laço
    
    if attempt >= max_attempts:
        print("Número máximo de tentativas atingido.")
        break  # Sai do laço
    
    print("Falha na conexão. Tentando novamente...")

print("Processo finalizado.")</code></pre>
            
            <pre><code># Exemplo de continue em um laço while
import random

count = 0
successful_pings = 0

while count < 10:
    count += 1
    print(f"Ping {count}...")
    
    # Simula um ping
    latency = random.randint(0, 500)  # Latência em ms
    
    if latency > 100:
        print(f"Latência alta: {latency}ms. Ignorando este resultado.")
        continue  # Pula para a próxima iteração
    
    successful_pings += 1
    print(f"Ping bem-sucedido. Latência: {latency}ms")

print(f"Total de pings bem-sucedidos com baixa latência: {successful_pings}/10")</code></pre>
            
            <h3>Aplicação em Redes: Verificação de Dispositivos com Timeout</h3>
            
            <p>Vamos ver um exemplo prático de como usar <code>break</code> e <code>continue</code> em um cenário de verificação de dispositivos de rede:</p>
            
            <pre><code>import subprocess
import time

def ping_with_timeout(ip, timeout=5):
    """
    Tenta fazer ping em um dispositivo com timeout
    """
    start_time = time.time()
    
    try:
        result = subprocess.call(
            ["ping", "-c", "1", "-W", "1", ip],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL
        )
        
        elapsed_time = time.time() - start_time
        
        if elapsed_time > timeout:
            return False, "Timeout"
        
        return result == 0, "Success" if result == 0 else "Failed"
    except Exception:
        return False, "Error"

def verify_network_segment(network_prefix, start_ip, end_ip):
    """
    Verifica dispositivos em um segmento de rede
    """
    print(f"Verificando dispositivos no segmento {network_prefix}.{start_ip}-{end_ip}")
    
    active_devices = []
    unreachable_count = 0
    max_consecutive_unreachable = 5
    
    for i in range(start_ip, end_ip + 1):
        ip = f"{network_prefix}.{i}"
        print(f"Verificando IP: {ip}...", end=" ")
        
        success, status = ping_with_timeout(ip)
        
        if success:
            print(f"Ativo ({status})")
            active_devices.append(ip)
            unreachable_count = 0  # Reseta o contador
        else:
            print(f"Inativo ({status})")
            unreachable_count += 1
            
            # Se muitos dispositivos consecutivos estiverem inacessíveis,
            # pode ser um problema de rede ou um segmento vazio
            if unreachable_count >= max_consecutive_unreachable:
                print(f"Detectados {max_consecutive_unreachable} dispositivos inacessíveis consecutivos.")
                print("Possível problema de rede ou segmento vazio. Interrompendo verificação.")
                break
        
        # Se já encontramos muitos dispositivos, podemos parar para economizar tempo
        if len(active_devices) >= 10:
            print("Encontrados dispositivos suficientes. Interrompendo verificação.")
            break
    
    return active_devices

# Exemplo de uso
network_prefix = "192.168.1"
active_devices = verify_network_segment(network_prefix, 1, 30)

print("\nResumo:")
print(f"Total de dispositivos ativos encontrados: {len(active_devices)}")
if active_devices:
    print("Dispositivos ativos:")
    for ip in active_devices:
        print(f"- {ip}")
else:
    print("Nenhum dispositivo ativo encontrado no segmento.")</code></pre>
            
            <p>Este exemplo demonstra como usar <code>break</code> para interromper a verificação de um segmento de rede quando certas condições são atendidas (muitos dispositivos inacessíveis consecutivos ou número suficiente de dispositivos encontrados). Isso torna o script mais eficiente, evitando verificações desnecessárias.</p>
        </section>

        <section id="list-comprehension">
            <h2>Compreensão de Listas</h2>
            
            <p>A compreensão de listas (list comprehension) é uma característica poderosa do Python que permite criar listas de forma concisa e elegante. É uma alternativa mais compacta e muitas vezes mais legível do que usar laços <code>for</code> tradicionais para criar listas.</p>
            
            <h3>Sintaxe Básica</h3>
            
            <pre><code># Sintaxe básica de compreensão de lista
nova_lista = [expressão for item in sequência]

# Equivalente usando laço for tradicional
nova_lista = []
for item in sequência:
    nova_lista.append(expressão)</code></pre>
            
            <h3>Exemplos Simples</h3>
            
            <pre><code># Criando uma lista de quadrados
squares = [x**2 for x in range(1, 11)]
print(squares)  # [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

# Criando uma lista de endereços IP
octets = [192, 168, 1]
ips = [f"{'.'.join(map(str, octets))}.{i}" for i in range(1, 11)]
print(ips)  # ['192.168.1.1', '192.168.1.2', ..., '192.168.1.10']</code></pre>
            
            <h3>Compreensão de Lista com Condição</h3>
            
            <p>Você pode adicionar uma condição para filtrar os elementos:</p>
            
            <pre><code># Sintaxe com condição
nova_lista = [expressão for item in sequência if condição]

# Exemplo: números pares de 1 a 20
even_numbers = [x for x in range(1, 21) if x % 2 == 0]
print(even_numbers)  # [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]

# Exemplo: dispositivos ativos
devices = [
    {"name": "Router1", "status": "active"},
    {"name": "Switch1", "status": "inactive"},
    {"name": "Firewall", "status": "active"},
    {"name": "AP1", "status": "active"},
    {"name": "Switch2", "status": "inactive"}
]

active_devices = [device["name"] for device in devices if device["status"] == "active"]
print(active_devices)  # ['Router1', 'Firewall', 'AP1']</code></pre>
            
            <h3>Compreensão de Lista com If-Else</h3>
            
            <p>Você também pode usar uma expressão condicional (operador ternário) na parte da expressão:</p>
            
            <pre><code># Sintaxe com expressão condicional
nova_lista = [expressão_if if condição else expressão_else for item in sequência]

# Exemplo: classificando números como "par" ou "ímpar"
numbers = [1, 2, 3, 4, 5]
parity = ["par" if x % 2 == 0 else "ímpar" for x in numbers]
print(parity)  # ['ímpar', 'par', 'ímpar', 'par', 'ímpar']

# Exemplo: classificando dispositivos por status
status_display = [f"{device['name']}: Online" if device['status'] == "active" 
                 else f"{device['name']}: Offline" for device in devices]
print(status_display)
# ['Router1: Online', 'Switch1: Offline', 'Firewall: Online', 'AP1: Online', 'Switch2: Offline']</code></pre>
            
            <h3>Compreensão de Lista Aninhada</h3>
            
            <p>Você pode usar múltiplos laços <code>for</code> em uma compreensão de lista:</p>
            
            <pre><code># Sintaxe com múltiplos laços for
nova_lista = [expressão for item1 in sequência1 for item2 in sequência2]

# Exemplo: combinações de VLANs e interfaces
vlans = [10, 20, 30]
interfaces = ["Gi0/1", "Gi0/2"]
combinations = [f"{interface} - VLAN {vlan}" for interface in interfaces for vlan in vlans]
print(combinations)
# ['Gi0/1 - VLAN 10', 'Gi0/1 - VLAN 20', 'Gi0/1 - VLAN 30', 
#  'Gi0/2 - VLAN 10', 'Gi0/2 - VLAN 20', 'Gi0/2 - VLAN 30']</code></pre>
            
            <h3>Aplicação em Redes: Geração de Configurações</h3>
            
            <p>Vamos ver um exemplo prático de como usar compreensão de listas para gerar configurações de rede:</p>
            
            <pre><code>def generate_switch_config(hostname, vlans, access_ports, trunk_ports):
    """
    Gera configuração básica para um switch Cisco
    """
    # Configuração base
    base_config = [
        f"hostname {hostname}",
        "no ip domain-lookup",
        "spanning-tree mode rapid-pvst",
        "service password-encryption",
        "!"
    ]
    
    # Configuração de VLANs usando compreensão de lista
    vlan_config = [f"vlan {vlan['id']}\n name {vlan['name']}\n!" for vlan in vlans]
    
    # Configuração de interfaces de acesso
    access_config = [
        f"interface {port['interface']}\n description {port['description']}\n"
        f" switchport mode access\n switchport access vlan {port['vlan']}\n"
        f" spanning-tree portfast\n!"
        for port in access_ports
    ]
    
    # Configuração de interfaces trunk
    trunk_config = [
        f"interface {port['interface']}\n description {port['description']}\n"
        f" switchport mode trunk\n switchport trunk allowed vlan {port['allowed_vlans']}\n!"
        for port in trunk_ports
    ]
    
    # Combinando todas as configurações
    full_config = base_config + vlan_config + access_config + trunk_config
    
    return "\n".join(full_config)

# Dados para o switch
switch_data = {
    "hostname": "SW-FLOOR1-01",
    "vlans": [
        {"id": 10, "name": "DATA"},
        {"id": 20, "name": "VOICE"},
        {"id": 30, "name": "MANAGEMENT"},
        {"id": 99, "name": "NATIVE"}
    ],
    "access_ports": [
        {"interface": "GigabitEthernet0/1", "description": "User PC", "vlan": 10},
        {"interface": "GigabitEthernet0/2", "description": "IP Phone", "vlan": 20},
        {"interface": "GigabitEthernet0/3", "description": "Printer", "vlan": 10}
    ],
    "trunk_ports": [
        {"interface": "GigabitEthernet0/24", "description": "Uplink to Core", "allowed_vlans": "10,20,30,99"}
    ]
}

# Gerando a configuração
config = generate_switch_config(
    switch_data["hostname"],
    switch_data["vlans"],
    switch_data["access_ports"],
    switch_data["trunk_ports"]
)

print(config)</code></pre>
            
            <p>Este exemplo demonstra como usar compreensão de listas para gerar configurações de switch de forma concisa e legível. A compreensão de listas é usada para criar as configurações de VLANs, interfaces de acesso e interfaces trunk, tornando o código mais compacto e expressivo.</p>
            
            <h3>Compreensão de Dicionário</h3>
            
            <p>Além da compreensão de listas, Python também suporta compreensão de dicionários, que segue uma sintaxe similar:</p>
            
            <pre><code># Sintaxe básica de compreensão de dicionário
novo_dict = {chave: valor for item in sequência}

# Exemplo: criando um dicionário de IPs e status
ips = ["192.168.1.1", "192.168.1.2", "192.168.1.3"]
ip_status = {ip: "online" for ip in ips}
print(ip_status)
# {'192.168.1.1': 'online', '192.168.1.2': 'online', '192.168.1.3': 'online'}

# Exemplo com condição: filtrando dispositivos por tipo
devices = [
    {"name": "R1", "type": "router", "ip": "10.0.0.1"},
    {"name": "S1", "type": "switch", "ip": "10.0.0.2"},
    {"name": "S2", "type": "switch", "ip": "10.0.0.3"},
    {"name": "AP1", "type": "ap", "ip": "10.0.0.4"}
]

# Criando um dicionário de switches (nome: ip)
switches = {device["name"]: device["ip"] for device in devices if device["type"] == "switch"}
print(switches)  # {'S1': '10.0.0.2', 'S2': '10.0.0.3'}</code></pre>
            
            <div class="note">
                <h4>Dica para Profissionais de Redes:</h4>
                <p>A compreensão de listas e dicionários é particularmente útil em automação de redes para processar grandes conjuntos de dados de dispositivos, gerar configurações em massa e transformar dados entre diferentes formatos. Embora poderosas, use-as com moderação e priorize a legibilidade do código.</p>
            </div>
        </section>

        <section id="exercicios">
            <h2>Exercícios Práticos</h2>
            
            <div class="exercise">
                <h4>Exercício 1: Verificador de Sub-rede</h4>
                <p>Crie um script Python que verifique todos os hosts em uma sub-rede /24 (ou um intervalo menor para teste) e identifique quais estão ativos. O script deve:</p>
                <ol>
                    <li>Aceitar um endereço de rede base (ex: 192.168.1.0)</li>
                    <li>Usar um laço para verificar cada endereço IP na sub-rede</li>
                    <li>Registrar quais IPs estão respondendo</li>
                    <li>Exibir um resumo dos resultados</li>
                </ol>
                <p>Dica: Use a função <code>ping_device</code> dos exemplos anteriores ou crie sua própria implementação.</p>
            </div>
            
            <div class="solution">
                <h4>Solução do Exercício 1:</h4>
                <pre><code>#!/usr/bin/env python3
# Verificador de Sub-rede

import subprocess
import time
import ipaddress
from datetime import datetime

def ping_device(ip_address, timeout=1):
    """
    Verifica se um dispositivo está acessível via ping
    Retorna True se o ping for bem-sucedido, False caso contrário
    """
    try:
        # Executa o comando ping (funciona em Windows e Linux)
        result = subprocess.call(
            ["ping", "-c", "1", "-W", str(timeout), str(ip_address)],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL
        )
        return result == 0
    except Exception:
        return False

def scan_subnet(network, start=1, end=254, max_threads=1):
    """
    Verifica hosts em uma sub-rede
    """
    # Validando a rede
    try:
        network_obj = ipaddress.IPv4Network(network, strict=False)
        network_address = str(network_obj.network_address)
        prefix = network_address.rsplit('.', 1)[0]
    except ValueError as e:
        print(f"Erro: {e}")
        return []
    
    print(f"Iniciando verificação da sub-rede {network}")
    print(f"Intervalo de hosts: {prefix}.{start} a {prefix}.{end}")
    print(f"Iniciado em: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print("-" * 60)
    
    active_hosts = []
    total_hosts = end - start + 1
    hosts_checked = 0
    
    # Para simplificar, usamos um loop sequencial
    # Em um ambiente real, você poderia usar threading para verificações paralelas
    start_time = time.time()
    
    for i in range(start, end + 1):
        ip = f"{prefix}.{i}"
        hosts_checked += 1
        
        # Exibindo progresso
        if hosts_checked % 10 == 0 or hosts_checked == total_hosts:
            percent = (hosts_checked / total_hosts) * 100
            elapsed = time.time() - start_time
            eta = (elapsed / hosts_checked) * (total_hosts - hosts_checked) if hosts_checked > 0 else 0
            print(f"Progresso: {percent:.1f}% ({hosts_checked}/{total_hosts}) - ETA: {eta:.1f}s", end="\r")
        
        # Verificando o host
        if ping_device(ip):
            active_hosts.append(ip)
            print(f"Host ativo encontrado: {ip}                ")
    
    elapsed_time = time.time() - start_time
    print(f"\nVerificação concluída em {elapsed_time:.2f} segundos")
    
    return active_hosts

def main():
    # Solicitando informações do usuário
    network = input("Digite o endereço de rede (ex: 192.168.1.0/24): ")
    
    try:
        # Validando a entrada
        network_obj = ipaddress.IPv4Network(network, strict=False)
        
        # Determinando o intervalo
        if network_obj.prefixlen < 24:
            print("Aviso: Sub-redes maiores que /24 podem levar muito tempo para verificar.")
            scan_all = input("Deseja verificar toda a sub-rede? (s/n): ").lower() == 's'
            
            if not scan_all:
                start = int(input("Digite o primeiro host a verificar (1-254): "))
                end = int(input("Digite o último host a verificar (1-254): "))
                start = max(1, min(254, start))
                end = max(1, min(254, end))
            else:
                start = 1
                end = 254
        else:
            start = 1
            end = min(254, 2 ** (32 - network_obj.prefixlen) - 2)
    
    except ValueError:
        print("Erro: Formato de rede inválido. Use o formato CIDR (ex: 192.168.1.0/24)")
        return
    
    # Executando a verificação
    active_hosts = scan_subnet(network, start, end)
    
    # Exibindo resultados
    print("\nResultados da Verificação:")
    print("-" * 60)
    print(f"Total de hosts verificados: {end - start + 1}")
    print(f"Hosts ativos encontrados: {len(active_hosts)}")
    
    if active_hosts:
        print("\nLista de hosts ativos:")
        for i, ip in enumerate(active_hosts, 1):
            print(f"{i}. {ip}")
    else:
        print("\nNenhum host ativo encontrado no intervalo especificado.")
    
    # Salvando resultados em arquivo
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    filename = f"subnet_scan_{timestamp}.txt"
    
    with open(filename, "w") as f:
        f.write(f"Verificação de Sub-rede: {network}\n")
        f.write(f"Intervalo: {start}-{end}\n")
        f.write(f"Data/Hora: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        f.write("-" * 60 + "\n")
        f.write(f"Total de hosts verificados: {end - start + 1}\n")
        f.write(f"Hosts ativos encontrados: {len(active_hosts)}\n\n")
        
        if active_hosts:
            f.write("Lista de hosts ativos:\n")
            for i, ip in enumerate(active_hosts, 1):
                f.write(f"{i}. {ip}\n")
        else:
            f.write("Nenhum host ativo encontrado no intervalo especificado.\n")
    
    print(f"\nResultados salvos em: {filename}")

if __name__ == "__main__":
    main()</code></pre>
            </div>
            
            <div class="exercise">
                <h4>Exercício 2: Analisador de Logs</h4>
                <p>Crie um script Python que analise um arquivo de log de um roteador (simulado) e extraia informações relevantes. O script deve:</p>
                <ol>
                    <li>Ler um arquivo de log (fornecido como uma string multi-linha no código)</li>
                    <li>Usar laços para processar cada linha do log</li>
                    <li>Extrair informações como timestamp, nível de severidade, mensagem</li>
                    <li>Contar ocorrências de diferentes tipos de eventos</li>
                    <li>Identificar os IPs mais frequentes mencionados nos logs</li>
                    <li>Gerar um relatório resumido</li>
                </ol>
            </div>
            
            <div class="solution">
                <h4>Solução do Exercício 2:</h4>
                <pre><code>#!/usr/bin/env python3
# Analisador de Logs de Roteador

import re
from datetime import datetime
from collections import Counter

# Simulação de um arquivo de log de roteador
router_log = """
May 20 2023 08:15:23: %SEC-6-IPACCESSLOGP: list 101 denied tcp 192.168.1.100(1234) -> 203.0.113.1(22), 1 packet
May 20 2023 08:15:25: %SEC-6-IPACCESSLOGP: list 101 denied tcp 192.168.1.100(1235) -> 203.0.113.1(22), 1 packet
May 20 2023 08:16:03: %LINK-3-UPDOWN: Interface GigabitEthernet0/1, changed state to down
May 20 2023 08:16:08: %LINEPROTO-5-UPDOWN: Line protocol on Interface GigabitEthernet0/1, changed state to down
May 20 2023 08:20:15: %SYS-5-CONFIG_I: Configured from console by admin on vty0 (192.168.1.5)
May 20 2023 08:25:12: %LINK-3-UPDOWN: Interface GigabitEthernet0/1, changed state to up
May 20 2023 08:25:14: %LINEPROTO-5-UPDOWN: Line protocol on Interface GigabitEthernet0/1, changed state to up
May 20 2023 09:01:48: %SEC-6-IPACCESSLOGP: list 101 permitted tcp 192.168.1.5(3456) -> 203.0.113.5(443), 1 packet
May 20 2023 09:30:22: %SYS-5-CONFIG_I: Configured from console by admin on vty0 (192.168.1.5)
May 20 2023 10:15:36: %SEC-6-IPACCESSLOGP: list 101 denied tcp 192.168.1.110(4321) -> 203.0.113.1(22), 1 packet
May 20 2023 10:45:27: %LINK-3-UPDOWN: Interface GigabitEthernet0/2, changed state to down
May 20 2023 10:45:29: %LINEPROTO-5-UPDOWN: Line protocol on Interface GigabitEthernet0/2, changed state to down
May 20 2023 11:02:18: %SYS-2-MALLOCFAIL: Memory allocation of 1028 bytes failed from 0x60A22F0C, alignment 0
May 20 2023 11:02:20: %SYS-2-MALLOCFAIL: Memory allocation of 2056 bytes failed from 0x60A22F0C, alignment 0
May 20 2023 11:05:41: %SYS-5-RELOAD: Reload requested by admin on vty0 (192.168.1.5). Reload Reason: Kernel panic.
May 20 2023 11:10:15: %SYS-5-RESTART: System restarted --
May 20 2023 11:10:18: %LINK-3-UPDOWN: Interface GigabitEthernet0/0, changed state to up
May 20 2023 11:10:20: %LINEPROTO-5-UPDOWN: Line protocol on Interface GigabitEthernet0/0, changed state to up
May 20 2023 11:10:25: %LINK-3-UPDOWN: Interface GigabitEthernet0/1, changed state to up
May 20 2023 11:10:27: %LINEPROTO-5-UPDOWN: Line protocol on Interface GigabitEthernet0/1, changed state to up
May 20 2023 11:15:32: %SEC-6-IPACCESSLOGP: list 101 permitted tcp 192.168.1.5(5678) -> 203.0.113.5(443), 1 packet
May 20 2023 12:30:45: %SYS-5-CONFIG_I: Configured from console by admin on vty0 (192.168.1.5)
"""

def parse_log_entry(log_line):
    """
    Analisa uma linha de log e extrai informações relevantes
    """
    # Padrão para extrair timestamp, facility, severity, mnemonic e mensagem
    pattern = r"(\w+ \d+ \d+ \d+:\d+:\d+): %(\w+)-(\d+)-(\w+): (.*)"
    match = re.match(pattern, log_line.strip())
    
    if not match:
        return None
    
    timestamp_str, facility, severity, mnemonic, message = match.groups()
    
    # Convertendo timestamp para objeto datetime
    try:
        timestamp = datetime.strptime(timestamp_str, "%b %d %Y %H:%M:%S")
    except ValueError:
        timestamp = None
    
    # Extraindo IPs da mensagem
    ip_pattern = r"\b(?:\d{1,3}\.){3}\d{1,3}\b"
    ips = re.findall(ip_pattern, message)
    
    # Extraindo interfaces
    interface_pattern = r"Interface (\w+\/\d+\/?\d*)"
    interface_match = re.search(interface_pattern, message)
    interface = interface_match.group(1) if interface_match else None
    
    # Determinando tipo de evento
    event_type = "unknown"
    if "denied" in message:
        event_type = "access_denied"
    elif "permitted" in message:
        event_type = "access_permitted"
    elif "changed state to up" in message:
        event_type = "interface_up"
    elif "changed state to down" in message:
        event_type = "interface_down"
    elif "CONFIG_I" in log_line:
        event_type = "configuration"
    elif "MALLOCFAIL" in log_line:
        event_type = "memory_error"
    elif "RELOAD" in log_line or "RESTART" in log_line:
        event_type = "system_restart"
    
    return {
        "timestamp": timestamp,
        "facility": facility,
        "severity": int(severity),
        "mnemonic": mnemonic,
        "message": message,
        "ips": ips,
        "interface": interface,
        "event_type": event_type
    }

def analyze_logs(log_data):
    """
    Analisa um conjunto de logs e extrai estatísticas
    """
    # Dividindo o log em linhas
    log_lines = [line for line in log_data.strip().split("\n") if line.strip()]
    
    # Analisando cada linha
    parsed_logs = []
    for line in log_lines:
        parsed = parse_log_entry(line)
        if parsed:
            parsed_logs.append(parsed)
    
    # Coletando estatísticas
    event_counts = Counter(entry["event_type"] for entry in parsed_logs)
    severity_counts = Counter(entry["severity"] for entry in parsed_logs)
    facility_counts = Counter(entry["facility"] for entry in parsed_logs)
    
    # Coletando IPs
    all_ips = []
    for entry in parsed_logs:
        all_ips.extend(entry["ips"])
    ip_counts = Counter(all_ips)
    
    # Coletando interfaces
    interfaces = [entry["interface"] for entry in parsed_logs if entry["interface"]]
    interface_counts = Counter(interfaces)
    
    # Identificando eventos por hora
    hour_counts = Counter(entry["timestamp"].hour for entry in parsed_logs if entry["timestamp"])
    
    # Identificando eventos críticos (severidade <= 2)
    critical_events = [entry for entry in parsed_logs if entry["severity"] <= 2]
    
    return {
        "total_entries": len(parsed_logs),
        "event_counts": event_counts,
        "severity_counts": severity_counts,
        "facility_counts": facility_counts,
        "ip_counts": ip_counts,
        "interface_counts": interface_counts,
        "hour_counts": hour_counts,
        "critical_events": critical_events,
        "parsed_logs": parsed_logs
    }

def generate_report(analysis):
    """
    Gera um relatório baseado na análise dos logs
    """
    report = []
    report.append("Relatório de Análise de Logs de Roteador")
    report.append("========================================")
    report.append("")
    
    # Resumo geral
    report.append(f"Total de entradas analisadas: {analysis['total_entries']}")
    report.append("")
    
    # Eventos por tipo
    report.append("Eventos por Tipo:")
    for event_type, count in analysis['event_counts'].most_common():
        report.append(f"  {event_type}: {count}")
    report.append("")
    
    # Eventos por severidade
    report.append("Eventos por Severidade:")
    severity_names = {
        0: "Emergência",
        1: "Alerta",
        2: "Crítico",
        3: "Erro",
        4: "Aviso",
        5: "Notificação",
        6: "Informacional",
        7: "Depuração"
    }
    for severity, count in sorted(analysis['severity_counts'].items()):
        report.append(f"  {severity} ({severity_names.get(severity, 'Desconhecido')}): {count}")
    report.append("")
    
    # IPs mais frequentes
    report.append("IPs mais frequentes:")
    for ip, count in analysis['ip_counts'].most_common(5):
        report.append(f"  {ip}: {count}")
    report.append("")
    
    # Interfaces mencionadas
    report.append("Interfaces mencionadas:")
    for interface, count in analysis['interface_counts'].most_common():
        report.append(f"  {interface}: {count}")
    report.append("")
    
    # Eventos por hora
    report.append("Distribuição de eventos por hora:")
    for hour, count in sorted(analysis['hour_counts'].items()):
        report.append(f"  {hour:02d}:00 - {hour:02d}:59: {count}")
    report.append("")
    
    # Eventos críticos
    report.append("Eventos críticos (severidade <= 2):")
    if analysis['critical_events']:
        for event in analysis['critical_events']:
            timestamp = event['timestamp'].strftime("%Y-%m-%d %H:%M:%S") if event['timestamp'] else "Unknown"
            report.append(f"  {timestamp}: {event['facility']}-{event['severity']}-{event['mnemonic']}: {event['message']}")
    else:
        report.append("  Nenhum evento crítico encontrado.")
    report.append("")
    
    # Análise de tendências
    report.append("Análise de Tendências:")
    
    # Verificando problemas de interface
    interface_down_events = [e for e in analysis['parsed_logs'] if e['event_type'] == 'interface_down']
    if interface_down_events:
        report.append("  Interfaces com problemas detectados:")
        affected_interfaces = Counter(e['interface'] for e in interface_down_events if e['interface'])
        for interface, count in affected_interfaces.most_common():
            report.append(f"    {interface}: {count} eventos de queda")
    
    # Verificando tentativas de acesso negadas
    denied_access = [e for e in analysis['parsed_logs'] if e['event_type'] == 'access_denied']
    if denied_access:
        report.append("  Tentativas de acesso negadas:")
        source_ips = []
        for event in denied_access:
            # Extraindo IP de origem das mensagens de acesso negado
            src_pattern = r"(\d+\.\d+\.\d+\.\d+)\(\d+\) -> "
            match = re.search(src_pattern, event['message'])
            if match:
                source_ips.append(match.group(1))
        
        src_ip_counts = Counter(source_ips)
        for ip, count in src_ip_counts.most_common():
            report.append(f"    {ip}: {count} tentativas negadas")
    
    # Verificando reinicializações do sistema
    restarts = [e for e in analysis['parsed_logs'] if e['event_type'] == 'system_restart']
    if restarts:
        report.append(f"  Sistema foi reiniciado {len(restarts)} vezes durante o período analisado.")
    
    return "\n".join(report)

# Analisando os logs
analysis_results = analyze_logs(router_log)

# Gerando e exibindo o relatório
report = generate_report(analysis_results)
print(report)

# Salvando o relatório em um arquivo
with open("router_log_analysis.txt", "w") as f:
    f.write(report)</code></pre>
            </div>
            
            <div class="exercise">
                <h4>Exercício 3: Gerador de Configuração em Massa</h4>
                <p>Crie um script Python que gere configurações para múltiplos switches em uma rede. O script deve:</p>
                <ol>
                    <li>Definir um template de configuração básica para switches</li>
                    <li>Ler uma lista de switches (nome, IP, VLANs, etc.) de um dicionário</li>
                    <li>Usar laços para gerar configurações personalizadas para cada switch</li>
                    <li>Usar compreensão de listas para gerar configurações de interfaces e VLANs</li>
                    <li>Salvar cada configuração em um arquivo separado (simulado no código)</li>
                </ol>
            </div>
            
            <div class="solution">
                <h4>Solução do Exercício 3:</h4>
                <pre><code>#!/usr/bin/env python3
# Gerador de Configuração em Massa para Switches

def generate_vlan_config(vlans):
    """
    Gera configuração de VLANs usando compreensão de lista
    """
    return [f"vlan {vlan['id']}\n name {vlan['name']}" for vlan in vlans]

def generate_interface_config(interfaces):
    """
    Gera configuração de interfaces usando compreensão de lista
    """
    configs = []
    
    # Interfaces de acesso
    access_configs = [
        f"interface {intf['id']}\n"
        f" description {intf['description']}\n"
        f" switchport mode access\n"
        f" switchport access vlan {intf['vlan']}\n"
        f" spanning-tree portfast\n"
        f" no shutdown"
        for intf in interfaces if intf['type'] == 'access'
    ]
    
    # Interfaces trunk
    trunk_configs = [
        f"interface {intf['id']}\n"
        f" description {intf['description']}\n"
        f" switchport mode trunk\n"
        f" switchport trunk allowed vlan {intf['allowed_vlans']}\n"
        f" switchport trunk native vlan {intf['native_vlan']}\n"
        f" no shutdown"
        for intf in interfaces if intf['type'] == 'trunk'
    ]
    
    return access_configs + trunk_configs

def generate_switch_config(switch_data):
    """
    Gera configuração completa para um switch
    """
    # Extraindo dados do switch
    hostname = switch_data['hostname']
    mgmt_ip = switch_data['mgmt_ip']
    mgmt_mask = switch_data['mgmt_mask']
    mgmt_vlan = switch_data['mgmt_vlan']
    default_gateway = switch_data['default_gateway']
    vlans = switch_data['vlans']
    interfaces = switch_data['interfaces']
    
    # Configuração básica
    basic_config = [
        f"hostname {hostname}",
        "no ip domain-lookup",
        "service password-encryption",
        "spanning-tree mode rapid-pvst",
        "spanning-tree portfast default",
        "spanning-tree extend system-id",
        "",
        "enable secret cisco123",
        "username admin privilege 15 secret cisco123",
        "",
        "vtp mode transparent",
        "",
        f"interface Vlan{mgmt_vlan}",
        f" description Management Interface",
        f" ip address {mgmt_ip} {mgmt_mask}",
        f" no shutdown",
        "",
        f"ip default-gateway {default_gateway}",
        "",
        "ip http server",
        "ip http secure-server",
        "",
        "line con 0",
        " exec-timeout 5 0",
        " logging synchronous",
        " login local",
        "",
        "line vty 0 15",
        " exec-timeout 5 0",
        " logging synchronous",
        " login local",
        " transport input ssh",
        ""
    ]
    
    # Gerando configurações de VLANs e interfaces
    vlan_config = generate_vlan_config(vlans)
    interface_config = generate_interface_config(interfaces)
    
    # Combinando todas as configurações
    full_config = basic_config + [""] + vlan_config + [""] + interface_config
    
    return "\n".join(full_config)

def save_config_to_file(config, filename):
    """
    Salva a configuração em um arquivo (simulado)
    """
    print(f"Salvando configuração em {filename}...")
    # Em um ambiente real, você usaria:
    # with open(filename, 'w') as f:
    #     f.write(config)
    
    # Para este exercício, apenas retornamos o nome do arquivo
    return filename

def main():
    # Lista de switches para configurar
    switches = [
        {
            "hostname": "SW-FLOOR1-01",
            "mgmt_ip": "10.0.1.10",
            "mgmt_mask": "255.255.255.0",
            "mgmt_vlan": 99,
            "default_gateway": "10.0.1.1",
            "vlans": [
                {"id": 10, "name": "DATA"},
                {"id": 20, "name": "VOICE"},
                {"id": 30, "name": "GUEST"},
                {"id": 99, "name": "MANAGEMENT"}
            ],
            "interfaces": [
                {"id": "GigabitEthernet0/1", "type": "access", "description": "User PC", "vlan": 10},
                {"id": "GigabitEthernet0/2", "type": "access", "description": "User PC", "vlan": 10},
                {"id": "GigabitEthernet0/3", "type": "access", "description": "IP Phone", "vlan": 20},
                {"id": "GigabitEthernet0/4", "type": "access", "description": "IP Phone", "vlan": 20},
                {"id": "GigabitEthernet0/5", "type": "access", "description": "Guest Access", "vlan": 30},
                {"id": "GigabitEthernet0/24", "type": "trunk", "description": "Uplink to Core", "allowed_vlans": "10,20,30,99", "native_vlan": 99}
            ]
        },
        {
            "hostname": "SW-FLOOR2-01",
            "mgmt_ip": "10.0.1.11",
            "mgmt_mask": "255.255.255.0",
            "mgmt_vlan": 99,
            "default_gateway": "10.0.1.1",
            "vlans": [
                {"id": 10, "name": "DATA"},
                {"id": 20, "name": "VOICE"},
                {"id": 30, "name": "GUEST"},
                {"id": 99, "name": "MANAGEMENT"}
            ],
            "interfaces": [
                {"id": "GigabitEthernet0/1", "type": "access", "description": "User PC", "vlan": 10},
                {"id": "GigabitEthernet0/2", "type": "access", "description": "User PC", "vlan": 10},
                {"id": "GigabitEthernet0/3", "type": "access", "description": "IP Phone", "vlan": 20},
                {"id": "GigabitEthernet0/4", "type": "access", "description": "Conference Room", "vlan": 10},
                {"id": "GigabitEthernet0/5", "type": "access", "description": "Printer", "vlan": 10},
                {"id": "GigabitEthernet0/24", "type": "trunk", "description": "Uplink to Core", "allowed_vlans": "10,20,30,99", "native_vlan": 99}
            ]
        },
        {
            "hostname": "SW-FLOOR3-01",
            "mgmt_ip": "10.0.1.12",
            "mgmt_mask": "255.255.255.0",
            "mgmt_vlan": 99,
            "default_gateway": "10.0.1.1",
            "vlans": [
                {"id": 10, "name": "DATA"},
                {"id": 20, "name": "VOICE"},
                {"id": 30, "name": "GUEST"},
                {"id": 40, "name": "SERVERS"},
                {"id": 99, "name": "MANAGEMENT"}
            ],
            "interfaces": [
                {"id": "GigabitEthernet0/1", "type": "access", "description": "User PC", "vlan": 10},
                {"id": "GigabitEthernet0/2", "type": "access", "description": "User PC", "vlan": 10},
                {"id": "GigabitEthernet0/3", "type": "access", "description": "IP Phone", "vlan": 20},
                {"id": "GigabitEthernet0/4", "type": "access", "description": "IP Phone", "vlan": 20},
                {"id": "GigabitEthernet0/5", "type": "access", "description": "File Server", "vlan": 40},
                {"id": "GigabitEthernet0/6", "type": "access", "description": "Print Server", "vlan": 40},
                {"id": "GigabitEthernet0/24", "type": "trunk", "description": "Uplink to Core", "allowed_vlans": "10,20,30,40,99", "native_vlan": 99}
            ]
        }
    ]
    
    print(f"Gerando configurações para {len(switches)} switches...")
    
    # Gerando configurações para cada switch
    for i, switch in enumerate(switches, 1):
        print(f"\nProcessando switch {i}/{len(switches)}: {switch['hostname']}")
        
        # Gerando configuração
        config = generate_switch_config(switch)
        
        # Salvando configuração em arquivo
        filename = f"{switch['hostname']}_config.txt"
        save_config_to_file(config, filename)
        
        # Exibindo parte da configuração como exemplo
        print("\nPrimeiras 10 linhas da configuração:")
        for line in config.split("\n")[:10]:
            print(f"  {line}")
        print("  ...")
    
    print("\nGeração de configurações concluída!")
    
    # Demonstrando uso de compreensão de lista para análise
    print("\nAnálise da configuração gerada:")
    
    # Total de interfaces configuradas por switch
    interfaces_per_switch = {switch['hostname']: len(switch['interfaces']) for switch in switches}
    print("\nTotal de interfaces por switch:")
    for hostname, count in interfaces_per_switch.items():
        print(f"  {hostname}: {count} interfaces")
    
    # Total de VLANs configuradas por switch
    vlans_per_switch = {switch['hostname']: len(switch['vlans']) for switch in switches}
    print("\nTotal de VLANs por switch:")
    for hostname, count in vlans_per_switch.items():
        print(f"  {hostname}: {count} VLANs")
    
    # Switches com VLAN específica
    vlan_id_to_check = 40
    switches_with_vlan = [switch['hostname'] for switch in switches 
                         if any(vlan['id'] == vlan_id_to_check for vlan in switch['vlans'])]
    
    print(f"\nSwitches com VLAN {vlan_id_to_check}:")
    if switches_with_vlan:
        for hostname in switches_with_vlan:
            print(f"  {hostname}")
    else:
        print(f"  Nenhum switch com VLAN {vlan_id_to_check}")

if __name__ == "__main__":
    main()</code></pre>
            </div>
        </section>

        <section id="avaliacao">
            <h2>Avaliação do Módulo</h2>
            
            <div class="assessment">
                <h4>Quiz de Conhecimentos</h4>
                <p>Responda às seguintes perguntas para testar seu conhecimento sobre os conceitos apresentados neste módulo:</p>
                
                <ol>
                    <li>Qual é a diferença principal entre os laços <code>while</code> e <code>for</code> em Python?</li>
                    <li>O que acontece se você esquecer de incrementar a variável de controle em um laço <code>while</code>?</li>
                    <li>Qual é a função da instrução <code>break</code> em um laço?</li>
                    <li>Qual é a função da instrução <code>continue</code> em um laço?</li>
                    <li>Como você pode usar a função <code>range()</code> para gerar uma sequência de números pares de 2 a 20?</li>
                    <li>O que é uma compreensão de lista e qual é sua vantagem sobre um laço <code>for</code> tradicional?</li>
                    <li>Como você pode iterar simultaneamente sobre duas listas de mesmo tamanho em Python?</li>
                    <li>Qual é a sintaxe para adicionar uma condição em uma compreensão de lista?</li>
                    <li>Como você pode obter o índice de cada elemento ao iterar sobre uma lista?</li>
                    <li>Qual é a diferença entre compreensão de lista e compreensão de dicionário?</li>
                </ol>
            </div>
            
            <div class="solution">
                <h4>Respostas do Quiz:</h4>
                <ol>
                    <li><strong>Diferença entre while e for:</strong> O laço <code>while</code> executa um bloco de código enquanto uma condição específica for verdadeira, sendo útil quando não sabemos antecipadamente quantas iterações serão necessárias. O laço <code>for</code> itera sobre uma sequência (como uma lista ou range) e é mais adequado quando sabemos sobre quais elementos queremos iterar.</li>
                    <li><strong>Esquecer de incrementar em while:</strong> Se você esquecer de incrementar a variável de controle em um laço <code>while</code>, a condição nunca se tornará falsa (assumindo que ela era verdadeira inicialmente), resultando em um laço infinito que pode travar seu programa.</li>
                    <li><strong>Função do break:</strong> A instrução <code>break</code> é usada para sair completamente de um laço antes que a condição normal de saída seja atingida. Quando encontrada, o programa pula para a primeira linha após o fim do laço.</li>
                    <li><strong>Função do continue:</strong> A instrução <code>continue</code> é usada para pular o restante do código no laço atual e avançar para a próxima iteração. Diferentemente do <code>break</code>, o <code>continue</code> não sai do laço, apenas pula para a próxima iteração.</li>
                    <li><strong>Range para números pares:</strong> Você pode usar <code>range(2, 21, 2)</code> para gerar uma sequência de números pares de 2 a 20. O terceiro parâmetro (2) define o passo (step) entre os números.</li>
                    <li><strong>Compreensão de lista:</strong> Uma compreensão de lista é uma forma concisa de criar listas em Python. Sua vantagem sobre um laço <code>for</code> tradicional é a sintaxe mais compacta e geralmente mais legível, além de ser mais eficiente em termos de desempenho em muitos casos.</li>
                    <li><strong>Iterar sobre duas listas:</strong> Você pode usar a função <code>zip()</code> para iterar simultaneamente sobre duas listas de mesmo tamanho. Por exemplo: <code>for item1, item2 in zip(lista1, lista2):</code></li>
                    <li><strong>Condição em compreensão de lista:</strong> A sintaxe para adicionar uma condição em uma compreensão de lista é: <code>[expressão for item in sequência if condição]</code>. A condição vem após a parte do <code>for</code>.</li>
                    <li><strong>Obter índice ao iterar:</strong> Você pode usar a função <code>enumerate()</code> para obter o índice de cada elemento ao iterar sobre uma lista. Por exemplo: <code>for index, value in enumerate(lista):</code></li>
                    <li><strong>Diferença entre compreensão de lista e dicionário:</strong> A compreensão de lista cria uma lista usando a sintaxe <code>[expressão for item in sequência]</code>, enquanto a compreensão de dicionário cria um dicionário usando a sintaxe <code>{chave: valor for item in sequência}</code>. A principal diferença é que a compreensão de dicionário requer um par chave-valor, enquanto a compreensão de lista requer apenas um valor.</li>
                </ol>
            </div>
            
            <div class="assessment">
                <h4>Projeto Prático</h4>
                <p>Desenvolva um script Python que implemente um sistema de monitoramento periódico de dispositivos de rede. O script deve:</p>
                
                <ol>
                    <li>Ler uma lista de dispositivos de rede (nome, IP, tipo, importância) de um arquivo ou definida no código</li>
                    <li>Implementar um laço que verifica periodicamente o status de cada dispositivo</li>
                    <li>Registrar o histórico de status de cada dispositivo (quando ficou online/offline)</li>
                    <li>Calcular estatísticas como tempo de atividade (uptime), tempo médio entre falhas, etc.</li>
                    <li>Gerar alertas quando dispositivos importantes ficarem offline</li>
                    <li>Exibir um painel de status atualizado após cada ciclo de verificação</li>
                </ol>
                
                <p>Use laços <code>while</code>, <code>for</code>, <code>break</code>, <code>continue</code> e compreensão de listas conforme apropriado. O script deve ser capaz de lidar com diferentes tipos de dispositivos e prioridades.</p>
            </div>
        </section>

        <section id="referencias">
            <h2>Referências e Recursos Adicionais</h2>
            
            <div class="references">
                <h3>Documentação Oficial</h3>
                <ul>
                    <li><a href="https://docs.python.org/3/tutorial/controlflow.html#for-statements" target="_blank">Tutorial Python: Laços For</a></li>
                    <li><a href="https://docs.python.org/3/tutorial/controlflow.html#while-statements" target="_blank">Tutorial Python: Laços While</a></li>
                    <li><a href="https://docs.python.org/3/tutorial/controlflow.html#break-and-continue-statements-and-else-clauses-on-loops" target="_blank">Tutorial Python: Break e Continue</a></li>
                    <li><a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" target="_blank">Tutorial Python: Compreensão de Listas</a></li>
                </ul>
                
                <h3>Livros Recomendados</h3>
                <ul>
                    <li>Eric Matthes - "Python Crash Course" (Capítulo sobre Laços)</li>
                    <li>Al Sweigart - "Automate the Boring Stuff with Python" (Capítulo sobre Controle de Fluxo)</li>
                    <li>Kirk Byers - "Python for Network Engineers" (Seções sobre Automação com Laços)</li>
                </ul>
                
                <h3>Recursos Online</h3>
                <ul>
                    <li><a href="https://realpython.com/python-for-loop/" target="_blank">Real Python: Python For Loops</a></li>
                    <li><a href="https://realpython.com/python-while-loop/" target="_blank">Real Python: Python While Loops</a></li>
                    <li><a href="https://realpython.com/list-comprehension-python/" target="_blank">Real Python: Python List Comprehension</a></li>
                </ul>
                
                <h3>Recursos Específicos para Redes</h3>
                <ul>
                    <li><a href="https://pynet.twb-tech.com/blog/python/for-loops.html" target="_blank">PyNet: For Loops in Network Automation</a></li>
                    <li><a href="https://github.com/ktbyers/netmiko/tree/develop/examples" target="_blank">Exemplos do Netmiko no GitHub</a></li>
                    <li><a href="https://developer.cisco.com/learning/modules/programming-fundamentals/python-part2/step/1" target="_blank">Cisco DevNet: Python Programming for Network Engineers - Part 2</a></li>
                </ul>
            </div>
        </section>
        
        <div class="navigation-buttons">
            <a href="modulo3.html" class="btn">← Módulo Anterior: Estruturas Condicionais</a>
            <a href="modulo5.html" class="btn">Próximo Módulo: Funções →</a>
        </div>
    </main>

    <footer>
        <p>&copy; 2025 Curso de Python para Profissionais de Redes Cisco. Todos os direitos reservados.</p>
    </footer>
</body>
</html>
